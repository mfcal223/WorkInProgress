/* SETTING UP MINILIBX*/

Download the .zip. Extract it in the root folder of project.
Navigate into the minilibx folder and compile it. 
$> make

After running make, ensure that a libmlx.a file is created inside the MiniLibX 
directory. This static library will be linked when compiling your project.


/*MAKE FILES NOTES */
- ISSUE COMPILING AND INCLUDING HEADER
in your Makefile, you already have this line:
Makefile
CFLAGS = -Wall -Wextra -Werror -I$(INC_DIR) -I$(MLX_DIR) -I$(LIBFT_DIR)/inc
This is correct because it adds the minilibx-linux directory to the include path with -I$(MLX_DIR).

The error is occurring because:

You're trying to include the file as "minilibx-linux/mlx.h" in your header, but
The compiler is already being told to look in the minilibx-linux directory through the -I flag
When you use the -I flag in the compiler, it adds that directory to the search path, so you don't need to (and shouldn't) include the directory name in the include statement.

Here's what's happening:

When you write #include "minilibx-linux/mlx.h", the compiler looks for a file named exactly that
But because you've added -Iminilibx-linux to your compiler flags, the compiler is already looking in that directory, so you just need to use #include <mlx.h>
To fix this:

Modify your inc/so_long.h file as shown above
(# include <mlx.h>           /* This is the correct way when using -I flag */)


/*-------------------------------------*/

INITIALIZATION:

BASIC WINDOW MANAGEMENT: 
----------------------

mlx_init():
 This will establish a connection to the correct graphical system and will return a void * which holds the location of our current MLX instance.

mlx_new_window()
This will return a pointer to the window we have just created. We can give the window height, width and a title.

mlx_loop() to initiate the window rendering.


mlx_hook() and mlx_destroy_window()
mlx_hook() calls an auxiliary function (I called close_window) to be able to close  the window by click the [x] on the corner.
This action will call another function of the minilibx = mlx_destroy_window()


WRITING PIXELS TO A IMAGE
----------------------------

there are severak ways to put pixels to the window.
1. mlx_pixel_put function is very, very slow. This is because it tries to push the pixel instantly to the window (without waiting for the frame to be entirely rendered).
Because of this sole reason, we will have to buffer all of our pixels to a image, which we will then push to the window and manage the same thing with a custom made mlx_pixel_put().

we will use a data structure. 
typedef struct s_data
{
	void	*img;
	char	*addr;
	int		bits_per_pixel;
	int		line_length;
	int		endian;
}			t_data;

We create an image by doing 
img.img = mlx_new_image(mlx, 1920, 1080);

and then we can call `mlx_get_data_addr`, we pass `bits_per_pixel`, `line_length`, and `endian` by reference. These will then be set accordingly for the *current* data address.

Now we have the image address, but still no pixels. Before we start with this, we must understand that the bytes are not aligned, this means that the line_length differs from the actual window width. We therefore should ALWAYS calculate the memory offset using the line length set by mlx_get_data_addr.

We can calculate it very easily by using the following formula:

int offset = (y * line_length + x * (bits_per_pixel / 8));

my_mlx_pixel_put will include this calculation.

Note that this will cause an issue. Because an image is represented in real time in a window, changing the same image will cause a bunch of screen-tearing when writing to it. You should therefore create two or more images to hold your frames temporarily. You can then write to a temporary image, so that you donâ€™t have to write to the currently presented image.

Pushing images to a window
----------------------------


/* FOR TOMORROW */
in windows_init copie codigo de claude que sugiere mejorias para la version actual de windows_test.c

Key improvements:

Added bounds checking in my_mlx_pixel_put
Proper cleanup of resources in error cases
Created a t_vars struct to hold all program variables
Proper window cleanup in close_window
Better error handling throughout the program
include macros for height and iwdth of the window in header
defined a 2nd structure to be able to pass arguments