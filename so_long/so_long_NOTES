MINILIBX is an X server which allows "things" to be display on screen. 
It is build based on X.org library. This API allows display on screen think for beginners.


/* SETTING UP MINILIBX*/

Download the .zip. Extract it in the root folder of project.
Navigate into the minilibx folder and compile it. 
$> make

After running make, ensure that a libmlx.a file is created inside the MiniLibX 
directory. This static library will be linked when compiling your project.


/*MAKE FILES NOTES */
- ISSUE COMPILING AND INCLUDING HEADER
in your Makefile, you already have this line:
Makefile
CFLAGS = -Wall -Wextra -Werror -I$(INC_DIR) -I$(MLX_DIR) -I$(LIBFT_DIR)/inc
This is correct because it adds the minilibx-linux directory to the include path with -I$(MLX_DIR).

The error is occurring because:

You're trying to include the file as "minilibx-linux/mlx.h" in your header, but
The compiler is already being told to look in the minilibx-linux directory through the -I flag
When you use the -I flag in the compiler, it adds that directory to the search path, so you don't need to (and shouldn't) include the directory name in the include statement.

Here's what's happening:

When you write #include "minilibx-linux/mlx.h", the compiler looks for a file named exactly that
But because you've added -Iminilibx-linux to your compiler flags, the compiler is already looking in that directory, so you just need to use #include <mlx.h>
To fix this:

Modify your inc/so_long.h file as shown above
(# include <mlx.h>           /* This is the correct way when using -I flag */)


/*-------------------------------------*/

INITIALIZATION:

BASIC WINDOW MANAGEMENT: 
----------------------
(1) 
mlx_init():
 This will establish a connection to the correct graphical system and will return a void * which holds the location of our current MLX instance.

This sparks the connection to the X-server.

(2)
mlx_new_window()
This will return a pointer to the window we have just created. We can give the window height, width and a title.

A window is just a huge gigantic malloc.

(3)
mlx_loop() to initiate the window rendering.
This keeps the process "alive".
It is an >>event loop<<.

(4)
mlx_key_hook() ?????

"Hooking into events" = reacting to events, like pressing a key. Doing this triggers another function that will behave as a handler. 
Every event should have its prototype handler.

MLX_HOOK ES COMO KEY_HOOK??

(5)
mlx_hook() and mlx_destroy_window()
mlx_hook() calls an auxiliary function (I called close_window) to be able to close  the window by click the [x] on the corner.
This action will call another function of the minilibx = mlx_destroy_window()

this closes the connection and frees the display. It is a cleanup function.


(6) MLX_LOOP_HOOK
is triggered when no event is processed. pe. textthat changes color except when you press a key like SPACE


WRITING PIXELS TO A IMAGE
----------------------------

To put pixels in an image:  mlx_pixel_put function is very, very slow. This is because it tries to push the pixel instantly to the window (without waiting for the frame to be entirely rendered).
Because of this sole reason, we will have to buffer all of our pixels to a image, which we will then push to the window and manage the same thing with a custom made mlx_pixel_put().

we will use a image structure. 
typedef struct s_image
{
	void	*img;
	char	*addr;
	int		bits_per_pixel;
	int		line_length;
	int		endian;
}			t_image;

bits_per_pixel means exactly that. 1 pixel = 1 INT = 32 bits



We create an image by doing :

img.img = mlx_new_image(mlx, 1920, 1080);

and then we can call `mlx_get_image_addr`, we pass `bits_per_pixel`, `line_length`, and `endian` by reference. These will then be set accordingly for the *current* image address.

Now we have the image address, but still no pixels. Before we start with this, we must understand that the bytes are not aligned, this means that the line_length differs from the actual window width. We therefore should ALWAYS calculate the memory offset using the line length set by mlx_get_image_addr.

We can calculate it very easily by using the following formula:

int offset = (y * line_length + x * (bits_per_pixel / 8));

my_mlx_pixel_put will include this calculation.

Note that this will cause an issue. Because an image is represented in real time in a window, changing the same image will cause a bunch of screen-tearing when writing to it. You should therefore create two or more images to hold your frames temporarily. You can then write to a temporary image, so that you don’t have to write to the currently presented image.



Pushing images to a window
----------------------------

=========================================================================================
=========================================================================================
=========================================================================================
=========================================================================================

TENER EN CUENTA QUE EN LOS HEADER HABRA QUE USAR ESTRUCTURAS QUE SE INCLUYEN ENTRE SI. lA ESTRUCTURA DE LA VENTAA INCLUIRA LA DEIMAGENES, DE MAPA, DE COORDENADAS O DE LO QUE SEA QUE HAYA QUE USAR.

Main game structure includes:
- MLX connection
- Textures and images
- Map image
- Player position (ship)
- Game state (moves, collectibles, etc.)

1. Initialization Phase --> MAIN()
Program starts by checking command line arguments (must be 2: program name and map file)
Validates map file extension (must be .ber)

2. GAME_START()
2.1 Initializes game structure (t_game in my code, t_init in malaga) with default values.
/* for this I have: 
- added another struct to be the central image structure that connects all functions:
	Contains game state
	Holds graphics resources
	Stores map information
	Tracks player position and collectibles
*/
=========================================================================================
SO_LONG.C

GAME_START()
What is "-> path"? (in malaga code , the av[1] = "path" , in my code "game")
In your ft_start_map function, path is the file path to the map that the player wants to load. It is passed as an argument from main() and stored inside the t_game (or t_init) structure.
For example:
./so_long maps/map.ber
maps/map.ber → This is stored in game->path.
- - - > Why Do We Store path?
	It allows the game to know which file to read.
	Helps when reloading or validating the map.
	If needed, you can save game progress or reload the same map.

=========================================================================================
MAP FUNCTIONS
--------------
This set of functions is central to setting up the game's environment before entering the main 
gameplay loop, ensuring that the map data is available in both linked list and array formats for
further processing.
The overall process ensures that the map is correctly read from a file, that its dimensions are 
known, and that any potential errors (like memory allocation or file I/O issues) are handled 
gracefully.
By creating duplicate arrays of the map, the code seems designed to work with an immutable 
original (or to have one copy for checking game state and another for dynamic modifications, 
such as during pathfinding).

MAP() (ft_map())
Goal: Act as the central function to initialize the entire map structure within the game.
Workflow:
-> Initialization: It stores a temporary pointer to the game structure.
-> Map Loading: It calls ft_map_init to load the map from the file into the game’s linked list.
-> Error Handling: If the map loading fails, it frees the game structure and returns an error.
-> Dimension Calculation: It computes the map’s dimensions by calling:
------ft_map_x (for the width) using the first map node.
------ft_map_y (for the height) by iterating through the list.
-> Creating Map Arrays: It then duplicates the map into two separate 2D arrays:
------array_map – likely used for storing the original state of the map.
------array_ff – possibly intended for pathfinding or gameplay modifications.
-> Finalization: If either array creation fails, it performs cleanup (using ft_free_all) and 
returns an error. Otherwise, it updates the game pointer and signals successful initialization.

MAP_INITIALIZE() (ft_map_init)
Goal: Initialize the map from a file.
Workflow:
-> File Opening: It opens the map file (whose path is stored in the game structure) in read-only 
mode.
-> Error Checking: If the file cannot be opened, it calls an error handler (ft_map_error) and 
returns NULL.
-> Line Reading: It reads the file line by line using get_next_line.
-> Validation: For each line, it calls ft_check_empty_line to ensure the file doesn’t contain any 
invalid (empty) lines.
-> Cleanup: Once all lines are processed, the file descriptor is closed.


duplicate_map() (ex- ft_map_status)
Goal: Create a 2D array (an array of strings) that is a duplicate of the map stored in a linked 
list.
Workflow:
- Backup: It first saves the current pointer to the beginning of the map linked list.
- Allocation: It allocates memory for a character pointer array sized to hold each line of the
 map (plus one extra for a terminating NULL pointer).
- Duplication: It iterates through each node in the linked list. For every node, it duplicates 
the string (using a function like ft_strdup) that represents that line of the map.
- Error Handling: If any duplication fails, it frees any allocated memory using a helper 
(likely ft_free_status) and returns NULL.
- Restoration: It resets the game’s map pointer back to its original position.
- Completion: Finally, it marks the end of the array with NULL and returns the array.

int	map_x_width(t_map *width) // = num of columns (ft_map_x) = num of char
int	map_y_heigth(t_map *height) // = num of lines (ft_map_y) = num of nodes


=========================================================================================
---------------------------------------------------------------------------

/* MALAGA INIT STRUCTURE */
typedef struct s_init
{
	mlx_t			*mlx;			// Connection to the graphic display.
	t_txts			txts;			// Textures of the game.
	t_images		imgs;			// Images of the game.
	t_cell			cell;			// Object of the game.
	t_map			*map;			// Map of the game.
	t_coord			ship;			// Position of the player.
	t_coord			shark;			// Position of the enemy.
	t_coord			size;			// Size in pixels of the window.
	char			**status_a;		// Matrix of the map.
	char			**status_b;		// Matrix of the map.
	char			*path;			// Path to the map.
	int				moves;			// Number of moves.
	int				counter;		// Number of collectibles.
	int				collec;			// Number of collectibles.
	int				c;				// Collectibles collected.	
	int				flag;			// 0 = game, 1 = win, 2 = lose
	char			course;			// Direction of the player.
	bool			walking;		// Walking or not.
}	t_init;
---------------------------------------------------------------------------- 
=========================================================================================
=========================================================================================
2.2 Map Loading and Validation

Reads map file line by line✅
Creates a linked list structure to store the map✅
Validates map requirements:
a. Must be rectangular
b. Must be surrounded by walls
c. Must contain:
 i. One player (P)
 ii. At least one collectible (C)
 iii. One exit (E)
 iiii. Must be possible to reach all collectibles and exit

----------------------------------------------------------------------------

✅FIND_PLAYER()
search through the game’s map (stored as a 2D array of characters in game->array_map) to 
locate the cell that represents the player. 
When it finds that cell, it updates the ship field in the game structure (of type t_coord) 
with the player's x and y coordinates.

✅FT_FLOOD() / FT_FILL() / FT_CHECK_CELL()
--Validation of Map Solvability:
In many games (like so_long), it’s crucial to ensure that the level is solvable. This means the player should be able to reach all collectibles and the exit from the starting position.
--Marking Visited Cells:
By marking cells as visited (with 'F'), the algorithm avoids infinite loops and ensures that each cell is processed only once.
--Updating Game State:
As the algorithm “floods” through the accessible area, it uses helper functions (like ft_check_cell) to update the game state. This ensures that you know which important elements (exits, collectibles, etc.) are reachable.

After these functions run, you can compare these counters with the total number of collectibles and the expected exit count to determine if the map is valid—that is, if the player can reach all necessary elements.

! Although both ft_fill and ft_check_cell check for 'E', they serve different purposes.!

1️⃣ ft_fill(): Ensuring That the Exit Is Reachable
The primary role of ft_fill() is to perform the flood fill and ensure accessibility.
The condition if (tab[curr.y][curr.x] == 'E') stops the flood fill from passing through an exit, ensuring that the algorithm terminates early when an exit is found.
The return (game); prevents unnecessary recursive calls beyond the exit.
2️⃣ ft_check_cell(): Counting the Number of Exits Found
ft_check_cell() is used to track how many exits exist and are reachable.
While ft_fill() marks an exit as found and prevents further recursion, it does not count how many times an exit is encountered.
ft_check_cell() ensures that every encounter with an exit increases the count, which is important if there are multiple exits in the game.

----------------------------------------------------------------------------

FT_CHECK_FORM()
Iterates through each row to validates each character to ensure it belongs to the allowed set: floor (FLOOR), wall (WALL), player (PJ), collectible (C), or exit (EXIT).
also Checks if each row has the same width as the first row (game->size.x). If any row is different, it returns 1 (error).
If all rows match in length and contain only valid characters, it returns 0 (success).

🚨I AM NOT CHECKING IF THE MAP IS A SQUARE❌. i AM CHOOSING A VERY BROAD INTERPRETATION OF RECTANGLE AS IN A POLIGONE 4 FACES, WHERE EVERY LINE HAS THE SAME LENGTH, AND EVERY COLUMN THE SAME LENGTH.🚨

FT_CHECK_BORDERS()
Iterates through each row:
Ensures that the top (j == 0) and bottom (j == game->size.y - 1) rows contain only walls.
Ensures that the left (i == 0) and right (i == game->size.x - 1) edges of middle rows also contain only walls.
Returns 1 if any of these conditions fail; otherwise, returns 0.

------------------------------------------------------------------------------------
FT_COUNT_OBJS()

Is map->map[i] each line of the map?
Yes! Your t_map is a linked list, where:
- Each node (t_map) contains one full row of the map as a string (map->map).
- The linked list structure allows you to move to the next row using map = map->next;.

✔️ The outer while (map) loop iterates through each row in the map (linked list).
✔️ The inner while (map->map[i]) loop iterates through each character in that row.

Example: If your map file is:
1111
1P01
1C01
1E11

Then:

First node (map->map) = "1111"
Second node (map->next->map) = "1P01"
Third node (map->next->next->map) = "1C01"
Fourth node (map->next->next->next->map) = "1E11"
Each row is stored in a separate linked list node, and the function reads one row at a time while looping through each character in that row.

ft_check_obj()
/* compare quantity of elementes counted in the map and counted by 
flood fill (which are reachables)*/


ft_check_obj_nbr()
/* checks minimun quantities of main elements are fullfilled */


ft_check_failed()
/* cambiar nombre a map_check */
this functions organices the checking.
=====================================================================================

TEST DE MAPAS INVALIDOS
-----------------------
PROBLEM WHEN MAP IS NOT RECTANGULAR:
The most likely cause is that your map is not rectangular, meaning some rows are shorter than others.

Your ft_fill() function assumes all rows are of equal length (size.x).

If a row is shorter, then accessing tab[curr.y][curr.x] could be out of bounds.
Your duplicate_map() (or ft_strdup()) might be copying shorter rows, but ft_fill() assumes they are the same length.

If ft_fill() moves horizontally (curr.x + 1) on a short row, it accesses memory beyond the allocated row.

✅ Fix: Ensure ft_fill() Checks Row Length Before Accessing
Modify ft_fill() to check if curr.x is within the row’s actual length before accessing tab[curr.y][curr.x]:

	if (curr.x >= ft_strlen(tab[curr.y]))
		return (game);

📌 Additional Fix: Ensure ft_check_form() Detects Non-Rectangular Maps
Right now, your ft_check_form() function should already be checking for non-rectangular maps by ensuring all rows have the same length.

✅ Make sure you have this condition in ft_check_form():

if (ft_strlen(game->array_map[j]) != game->size.x)
	return (1); // Error: Rows must have same length

If this condition is already in ft_check_form(), then the invalid map should be rejected before reaching ft_fill().

📌TESTCASES : 

🚀 valgrind --leak-check=full ./so_long maps/map_error_empty_line.ber    

🎯 Works ok, no leaks: 💪🔥
1. MAP NO WALLS:
2. MAP with 1 SPACE IN WALL 
3. MAP WHERE Exit is not reachable, ('E'  is surrounded by '1' cells)
4. map that is not a rectangle:
5. empty line in map
6. no Collectible (no 'C' in the map)
7. no exit (no 'E' in the map)
8. no P
9. mutiple P
10. multiple E

📌 Other tests: 
Multiple Players ('P') in the Map
Multiple Exits ('E') in the Map
Extra Characters in the Map
📌 Why? The game should only allow 'P', 'C', 'E', '1', and '0'.
=====================================================================================
=========================================================================================
=========================================================================================




int	ft_key_check(t_init *game)
{
	if (game->status_a[game->ship.y - 1][game->ship.x] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_UP))
		return (1);
	if (game->status_a[game->ship.y + 1][game->ship.x] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_DOWN))
		return (2);
	if (game->status_a[game->ship.y][game->ship.x - 1] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_LEFT))
		return (3);
	if (game->status_a[game->ship.y][game->ship.x + 1] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_RIGHT))
		return (4);
	if (mlx_is_key_down(game->mlx, MLX_KEY_ESCAPE))
		return (5);
	return (0);
}




----------
next step
----------
3. Graphics Initialization

Initializes MLX42 library
Loads all required textures:
- - Ocean (background)
- Wall
- Ship (player) with different directions
- Collectibles
- Exit (closed and open states)
- Shark (enemy)
- Converts textures to images for display

4. Game Loop

Main game loop starts with mlx_loop()
Handles keyboard input through ft_key_press:
- Arrow keys for movement
- ESC to exit ✅
- Updates game state:
- Player position
- Collectibles collected
- Move counter
- Win/lose conditions


=========================================================

WHY IS IT game AND NOT *game IN MAIN()
Let me explain why game in main doesn't need to be declared as a pointer (t_game *game) and should remain as a regular structure variable (t_game game).

There are several important reasons:

Memory Management and Stack vs Heap:

When you declare t_game game in main, the structure is created on the stack
The stack memory is automatically managed (allocated when the function starts, deallocated when it ends)
If you declared t_game *game, you would need to:
C
t_game *game;
game = malloc(sizeof(t_game)); // Manual allocation required
if (!game)
    return (1);
// ... use game
free(game); // Manual deallocation required
Direct Access vs Indirect Access:

With t_game game:
C
game.mlx = mlx_init();
game.win = mlx_new_window(game.mlx, ...);
With t_game *game:
C
game->mlx = mlx_init();
game->win = mlx_new_window(game->mlx, ...);
Direct access is cleaner and slightly more efficient
Lifetime and Scope:

The game structure contains all your program's essential image
You want this image to exist for the entire duration of your program
Stack allocation in main guarantees this (it lives as long as main runs)
You don't need the flexibility of heap allocation here
MLX Event Handling:

When setting up event hooks, you pass &game to give MLX access to your structure:
C
mlx_hook(game.win, 17, 0, close_window, &game);
This creates a pointer when needed, without storing the structure itself as a pointer
Here's a metaphor that might help:

Think of game like your game's control panel
You want the actual panel (the structure) in your main room (main function)
When someone needs to make changes (like close_window), you give them directions to the panel (a pointer using &)
You don't want just directions to a panel (pointer) in your main room - you want the actual panel
So in summary:

C
int main(void)
{
    t_game game;        // ✅ The actual control panel
    // vs
    t_game *game;       // ❌ Just directions to a control panel that doesn't exist yet
This approach gives you:

Automatic memory management
Direct access to structure members
Clear ownership of the image
The ability to share the address when needed (using &game)

===================================================================

QUE TAL SI QUIERO DECLARAR EL PATH PARA EL FOLDER DE MAPS:

#include <fcntl.h>

#define MAP_FOLDER "src/maps/"

int main(int ac, char **av)
{
    char    *full_path;
    
    if (ac != 2)
    {
        ft_printf("Wrong input: try ./so_long <file with map.ber>\n");
        return (1);
    }
    if (check_extension(av[1]) == 1)
    {
        ft_printf("Wrong map extension. Try map.ber\n");
        return (1);
    }
    
    // Allocate and construct full path
    full_path = ft_strjoin(MAP_FOLDER, av[1]);
    if (!full_path)
    {
        ft_printf("Error: Memory allocation failed\n");
        return (1);
    }

    // Check if the file exists
    int fd = open(full_path, O_RDONLY);
    if (fd < 0)
    {
        ft_printf("Error: Cannot open %s\n", full_path);
        free(full_path);
        return (1);
    }
    close(fd);

    // Pass full path to window_init
    if (window_init(full_path) == 1)
    {
        free(full_path);
        return (1);
    }

    free(full_path);
    return (0);
}
