Introduction
Now that you know what MiniLibX is capable of doing, we will get started with doing some very basic things. These will provide you with a solid understanding of how to write performant code using this library. For a lot of projects, performance is the essence. It is therefore of utmost importance that you read through this section thoroughly.

Installation
Compilation on macOS
Because MiniLibX requires Cocoa of MacOSX (AppKit) and OpenGL (it doesn’t use X11 anymore) we need to link them accordingly. This can cause a complicated compilation process. A basic compilation process looks as follows.

For object files, you could add the following rule to your makefile, assuming that you have the mlx source in a directory named mlx in the root of your project:

%.o: %.c
	$(CC) -Wall -Wextra -Werror -Imlx -c $< -o $@

To link with the required internal macOS API:

$(NAME): $(OBJ)
	$(CC) $(OBJ) -Lmlx -lmlx -framework OpenGL -framework AppKit -o $(NAME)

Do mind that you need the libmlx.dylib in the same directory as your build target as it is a dynamic library!

Compilation on Linux
In case of Linux, you can use the Codam provided zip which is a Linux compatible MLX version. It has the exact same functions and shares the same function calls. Do mind, that using memory magic on images can differ as object implementations are architecture specific. Next, you should unzip the MLX for Linux in a new folder, in the root of your project, called mlx_linux.

MiniLibX for Linux requires xorg, x11 and zlib, therefore you will need to install the following dependencies: xorg, libxext-dev and zlib1g-dev. Installing these dependencies on Ubuntu can be done as follows:

sudo apt-get update && sudo apt-get install xorg libxext-dev zlib1g-dev libbsd-dev

Now all thats left is to configure MLX, just run the configure script in the root of the given repository, and you are good to go.

For object files, you could add the following rule to your makefile, assuming that you have the mlx for linux source in a directory named mlx_linux in the root of your project:

%.o: %.c
	$(CC) -Wall -Wextra -Werror -I/usr/include -Imlx_linux -O3 -c $< -o $@

To link with the required internal Linux API:

$(NAME): $(OBJ)
	$(CC) $(OBJ) -Lmlx_linux -lmlx_Linux -L/usr/lib -Imlx_linux -lXext -lX11 -lm -lz -o $(NAME)

Getting a screen on Windows 10 (WSL2)
Getting a screen on WSL2 with Windows 10 can be quite hard. I suggest you either use Windows 11 (as it has graphics support built-in) or use a VM.

Nonetheless, since WSL2 does hot have a graphics layer, you will have to connect to your screen through VNC. This requires a few steps for it to work accordingly:

Install Xming, just keep clicking next, the defaults will do. After installing, you will see a little Xming icon in your icon tray. Now exit xming, and open XLaunch, proceed with the following steps:
Click Multiple windows and go to the next page
Click Start no client and go to the next page
Make sure that the No Access Control box is ticked and go to the next page
Click Save configuration and then Finish
In WSL execute the following command, this will set your display environment variable accordingly (feel free to create an alias :D):
export DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk '{print $2}'):0.0

Now you can run graphical applications by calling them from your command line interface.
Help! It still does not work!
Firstly, validate that you are running WSL2. There is a great stackoverflow post about this that will surely help you. If it turns out you are running WSL 1, I strongly encourage you to upgrade, as it’s significantly faster. This should also solve your issues. However, if you really want to stick to WSL1, you can also set your display to localhost to solve your issues:

export DISPLAY=localhost:0.0

After you have validated you are running WSL2, what does the following script output?

$> echo $DISPLAY

You should be presented an ip address (can be any valid IP address), followed by :0.0. If your output does not contain a real IP address, or is blank, it might be that your /etc/resolv.conf file does not exist. Read the contents of the file (using cat /etc/resolv.conf) and make sure it looks something like this:

# This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:
# [network]
# generateResolvConf = false
nameserver 172.27.32.1

If the file is empty, try creating a WSL configuration file with the command below and restart your pc for the changes to get applied:

echo -e -n "[network]\ngenerateResolvConf = true\n" > /etc/wsl.conf

NOTE: This requires root proviliges to be executed.

If the file is not empty and contains an IP address, try setting your display directly using the following script. Replace [YOUR IP] with the value from your /etc/resolv.conf file.

export DISPLAY=[YOUR IP]:0.0

If I fill in the IP address from my /etc/resolv.conf it will look as follows:

export DISPLAY=172.27.32.1:0.0

If none of that worked, feel free to send me a message on slack (@hsmits).

Getting a screen on Windows 11 (WSLg)
Windows 11’s WSL comes with an option to run graphic applications directly. To enable this, follow their official guide for running linux gui apps in wsl. When you have finished the installation, you can simply compile and run minilibx apps and they will appear like an actual application as if they were executed in windows.

Initialization
Before we can do anything with the MiniLibX library we must include the <mlx.h> header to access all the functions and we should execute the mlx_init function. This will establish a connection to the correct graphical system and will return a void * which holds the location of our current MLX instance. To initialize MiniLibX one could do the following:

#include <mlx.h>

int	main(void)
{
	void	*mlx;

	mlx = mlx_init();
}

When you run the code, you can’t help but notice that nothing pops up and that nothing is being rendered. Well, this obviously has something to do with the fact that you are not creating a window yet, so let’s try initializing a tiny window which will stay open forever. You can close it by pressing CTRL + C in your terminal. To achieve this, we will simply call the mlx_new_window function, which will return a pointer to the window we have just created. We can give the window height, width and a title. We then will have to call mlx_loop to initiate the window rendering. Let’s create a window with a width of 1920, a height of 1080 and a name of “Hello world!”:

#include <mlx.h>

int	main(void)
{
	void	*mlx;
	void	*mlx_win;

	mlx = mlx_init();
	mlx_win = mlx_new_window(mlx, 1920, 1080, "Hello world!");
	mlx_loop(mlx);
}

Writing pixels to a image
Now that we have basic window management, we can get started with pushing pixels to the window. How you decide to get these pixels is up to you, however some optimized ways of doing this will be discussed. First of all, we should take into account that the mlx_pixel_put function is very, very slow. This is because it tries to push the pixel instantly to the window (without waiting for the frame to be entirely rendered). Because of this sole reason, we will have to buffer all of our pixels to a image, which we will then push to the window. All of this sounds very complicated, but trust me, its not too bad.

First of all, we should start by understanding what type of image mlx requires. If we initiate an image, we will have to pass a few pointers to which it will write a few important variables. The first one is the bpp, also called the bits per pixel. As the pixels are basically ints, these usually are 4 bytes, however, this can differ if we are dealing with a small endian (which means we most likely are on a remote display and only have 8 bit colors).

Now we can initialize the image with size 1920×1080 as follows:

#include <mlx.h>

int	main(void)
{
	void	*img;
	void	*mlx;

	mlx = mlx_init();
	img = mlx_new_image(mlx, 1920, 1080);
}

That wasn’t too bad, was it? Now, we have an image but how exactly do we write pixels to this? For this we need to get the memory address on which we will mutate the bytes accordingly. We retrieve this address as follows:

#include <mlx.h>

typedef struct	s_image {
	void	*img;
	char	*addr;
	int		bits_per_pixel;
	int		line_length;
	int		endian;
}				t_image;

int	main(void)
{
	void	*mlx;
	t_image	img;

	mlx = mlx_init();
	img.img = mlx_new_image(mlx, 1920, 1080);

	/*
	** After creating an image, we can call `mlx_get_image_addr`, we pass
	** `bits_per_pixel`, `line_length`, and `endian` by reference. These will
	** then be set accordingly for the *current* image address.
	*/
	img.addr = mlx_get_image_addr(img.img, &img.bits_per_pixel, &img.line_length,
								&img.endian);
}

Notice how we pass the bits_per_pixel, line_length and endian variables by reference? These will be set accordingly by MiniLibX as per described above.

Now we have the image address, but still no pixels. Before we start with this, we must understand that the bytes are not aligned, this means that the line_length differs from the actual window width. We therefore should ALWAYS calculate the memory offset using the line length set by mlx_get_image_addr.

We can calculate it very easily by using the following formula:

int offset = (y * line_length + x * (bits_per_pixel / 8));

Now that we know where to write, it becomes very easy to write a function that will mimic the behaviour of mlx_pixel_put but will simply be many times faster:

typedef struct	s_image {
	void	*img;
	char	*addr;
	int		bits_per_pixel;
	int		line_length;
	int		endian;
}				t_image;

void	my_mlx_pixel_put(t_image *image, int x, int y, int color)
{
	char	*dst;

	dst = image->addr + (y * image->line_length + x * (image->bits_per_pixel / 8));
	*(unsigned int*)dst = color;
}

Note that this will cause an issue. Because an image is represented in real time in a window, changing the same image will cause a bunch of screen-tearing when writing to it. You should therefore create two or more images to hold your frames temporarily. You can then write to a temporary image, so that you don’t have to write to the currently presented image.

Pushing images to a window
Now that we can finally create our image, we should also push it to the window, so that we can actually see it. This is pretty straight forward, let’s take a look at how we can write a red pixel at (5,5) and put it to our window:

#include <mlx.h>

typedef struct	s_image {
	void	*img;
	char	*addr;
	int		bits_per_pixel;
	int		line_length;
	int		endian;
}				t_image;

int	main(void)
{
	void	*mlx;
	void	*mlx_win;
	t_image	img;

	mlx = mlx_init();
	mlx_win = mlx_new_window(mlx, 1920, 1080, "Hello world!");
	img.img = mlx_new_image(mlx, 1920, 1080);
	img.addr = mlx_get_image_addr(img.img, &img.bits_per_pixel, &img.line_length,
								&img.endian);
	my_mlx_pixel_put(&img, 5, 5, 0x00FF0000);
	mlx_put_image_to_window(mlx, mlx_win, img.img, 0, 0);
	mlx_loop(mlx);
}

Note that 0x00FF0000 is the hex representation of ARGB(0,255,0,0).

Test your skills!
Now you that you understand the basics, get comfortable with the library and do some funky stuff! Here are a few ideas:

Print squares, circles, triangles and hexagons on the screen by writing the pixels accordingly.
Try adding gradients, making rainbows, and get comfortable with using the rgb colors.
Try making textures by generating the image in loops.

Colors
Table of contents
The color integer standard
Encoding and decoding colors
BitShifting
Char/int conversion
Test your skills!
Colors are presented in an int format. It therefore requires some tricky things in order to obtain an int which can contain the ARGB values.

The color integer standard
We shift bits to use the TRGB format. To define a color, we initialize it as follows: 0xTTRRGGBB, where each character represents the following:

Letter	Description
T	transparency
R	red component
G	green component
B	blue component
RGB colors can be initialized as above, a few examples would be:

Color	TRGB representation
red	0x00FF0000
green	0x0000FF00
blue	0x000000FF
Encoding and decoding colors
We can use two methods to encode and decode colors:

BitShifting
char/int conversion
BitShifting
Since each byte contains 2^8 = 256 values (1 byte = 8 bits), and RGB values range from 0 to 255, we can perfectly fit a integer (as an int is 4 bytes). In order to set the values programatically we use bitshifting. Let’s create a function which does precisely that for us, shall we?

int	create_trgb(int t, int r, int g, int b)
{
	return (t << 24 | r << 16 | g << 8 | b);
}

Because ints are stored from right to left, we need to bitshift each value the according amount of bits backwards. We can also do the exact opposite and retrieve integer values from a encoded TRGB integer.

int	get_t(int trgb)
{
	return ((trgb >> 24) & 0xFF);
}

int	get_r(int trgb)
{
	return ((trgb >> 16) & 0xFF);
}

int	get_g(int trgb)
{
	return ((trgb >> 8) & 0xFF);
}

int	get_b(int trgb)
{
	return (trgb & 0xFF);
}

Char/int conversion
Since each byte contains 2^8 = 256 values (1 byte = 8 bits), and RGB values range from 0 to 255, we can perfectly fit a unsigned char for each TRGB parameters {T, R, G, B} (char is 1 byte) and fit a int for the TRGB value (int is 4 bytes). In order to set the values programatically we use type converting.

int	create_trgb(unsigned char t, unsigned char r, unsigned char g, unsigned char b)
{
	return (*(int *)(unsigned char [4]){b, g, r, t});
}

unsigned char	get_t(int trgb)
{
	return (((unsigned char *)&trgb)[3]);
}

unsigned char	get_r(int trgb)
{
	return (((unsigned char *)&trgb)[2]);
}

unsigned char	get_g(int trgb)
{
	return (((unsigned char *)&trgb)[1]);
}

unsigned char	get_b(int trgb)
{
	return (((unsigned char *)&trgb)[0]);
}

To understand the conversion you can refere to the table bellow, where 0x0FAE1 is the variable address of int trgb.

Address	char	int
0x0FAE1	unsigned char b	int trgb
0x0FAE2	unsigned char g	[allocated]
0x0FAE3	unsigned char r	[allocated]
0x0FAE4	unsigned char t	[allocated]
Test your skills!
Now that you understand the basics of how the colors can be initialized, get comfy and try creating the following color manipulation functions:

add_shade is a function that accepts a double (distance) and a int (color) as arguments, 0 will add no shading to the color, whilst 1 will make the color completely dark. 0.5 will dim it halfway, and .25 a quarter way. You get the point.
get_opposite is a function that accepts a int (color) as argument and that will invert the color accordingly.

Events
Table of contents
Introduction
MacOS version
X11 interface
X11 events
X11 masks
Hooking into events
mlx_hook
Prototype of event functions
Hooking alias
Example
Test your skills!
Introduction
Events are the foundation of writing interactive applications in MiniLibX. It is therefore of essence that you fully comprehend this chapter as this will be of use in your future graphical projects.

All hooks in MiniLibX are nothing more than a function that gets called whenever a event is triggered. Mastering all these events won’t be neccessary, however, we will quickly go over each X11 event accordingly.

MacOS version
Note: On MacOS - Cocoa (AppKit) and OpenGL - version, minilibx has partial support of X11 events and doesn’t support X11 mask (x_mask argument of mlx_hook is useless, keep it at 0).

Supported events:

enum {
	ON_KEYDOWN = 2,
	ON_KEYUP = 3,
	ON_MOUSEDOWN = 4,
	ON_MOUSEUP = 5,
	ON_MOUSEMOVE = 6,
	ON_EXPOSE = 12,
	ON_DESTROY = 17
};

// usage:
mlx_hook(game.win, ON_DESTROY, 0, close, &game);

X11 interface
X11 is the library that is used alongside of MiniLibX. It therefore is no secret that this header is very useful for finding all the according events of MiniLibX.

X11 events
There are a number of events to which you may describe.

Key	Event	 	Key	Event	 	Key	Event
02	KeyPress	 	14	NoExpose	 	26	CirculateNotify
03	KeyRelease	 	15	VisibilityNotify	 	27	CirculateRequest
04	ButtonPress	 	16	CreateNotify	 	28	PropertyNotify
05	ButtonRelease	 	17	DestroyNotify	 	29	SelectionClear
06	MotionNotify	 	18	UnmapNotify	 	30	SelectionRequest
07	EnterNotify	 	19	MapNotify	 	31	SelectionNotify
08	LeaveNotify	 	20	MapRequest	 	32	ColormapNotify
09	FocusIn	 	21	ReparentNotify	 	33	ClientMessage
10	FocusOut	 	22	ConfigureNotify	 	34	MappingNotify
11	KeymapNotify	 	23	ConfigureRequest	 	35	GenericEvent
12	Expose	 	24	GravityNotify	 	36	LASTEvent
13	GraphicsExpose	 	25	ResizeRequest	 	 	 
If you can’t figure out what some events are, don’t worry, because you probably won’t need them. If you do, go read the documentation of each X11 events.

X11 masks
Each X11 event, also has an according mask. This way you can register to only one key when it triggers, or to all keys if you leave your mask to the default. Key masks therefore allow you to whitelist / blacklist events from your event subscriptions. The following masks are allowed:

Mask	Description	 	Mask	Description
0L	NoEventMask	 	(1L<<12)	Button5MotionMask
(1L<<0)	KeyPressMask	 	(1L<<13)	ButtonMotionMask
(1L<<1)	KeyReleaseMask	 	(1L<<14)	KeymapStateMask
(1L<<2)	ButtonPressMask	 	(1L<<15)	ExposureMask
(1L<<3)	ButtonReleaseMask	 	(1L<<16)	VisibilityChangeMask
(1L<<4)	EnterWindowMask	 	(1L<<17)	StructureNotifyMask
(1L<<5)	LeaveWindowMask	 	(1L<<18)	ResizeRedirectMask
(1L<<6)	PointerMotionMask	 	(1L<<19)	SubstructureNotifyMask
(1L<<7)	PointerMotionHintMask	 	(1L<<20)	SubstructureRedirectMask
(1L<<8)	Button1MotionMask	 	(1L<<21)	FocusChangeMask
(1L<<9)	Button2MotionMask	 	(1L<<22)	PropertyChangeMask
(1L<<10)	Button3MotionMask	 	(1L<<23)	ColormapChangeMask
(1L<<11)	Button4MotionMask	 	(1L<<24)	OwnerGrabButtonMask
Hooking into events
mlx_hook
Hooking into events is one of the most powerful tools that MiniLibX provides. It allows you to register to any of the aforementioned events with the call of a simple hook registration function.

To achieve this, we call the function mlx_hook.

void mlx_hook(mlx_win_list_t *win_ptr, int x_event, int x_mask, int (*f)(), void *param)

Some version of mlbx doesn’t implement x_mask and whatever the value there will be no mask.

Prototype of event functions
Event functions have a different prototype depending of the hooking event.

Hooking event	code	Prototype
ON_KEYDOWN	2	int (*f)(int keycode, void *param)
ON_KEYUP*	3	int (*f)(int keycode, void *param)
ON_MOUSEDOWN*	4	int (*f)(int button, int x, int y, void *param)
ON_MOUSEUP	5	int (*f)(int button, int x, int y, void *param)
ON_MOUSEMOVE	6	int (*f)(int x, int y, void *param)
ON_EXPOSE*	12	int (*f)(void *param)
ON_DESTROY	17	int (*f)(void *param)
*Has mlx_hook alias.

Hooking alias
Minilibx api has some alias hooking function:

mlx_expose_hook function is an alias of mlx_hook on expose event (12).
mlx_key_hook function is an alias of mlx_hook on key up event (3).
mlx_mouse_hook function is an alias of mlx_hook on mouse down event (4).
Example
For example instead of calling mlx_key_hook, we can also register to the KeyPress and KeyRelease events. Lets take a look:

#include <mlx.h>

typedef struct	s_game {
	void	*mlx;
	void	*win;
}				t_game;

int	close(int keycode, t_game *game)
{
	mlx_destroy_window(game->mlx, game->win);
	return (0);
}

int	main(void)
{
	t_game	game;

	game.mlx = mlx_init();
	game.win = mlx_new_window(game.mlx, 1920, 1080, "Hello world!");
	mlx_hook(game.win, 2, 1L<<0, close, &game);
	mlx_loop(game.mlx);
}

Here we register to the KeyPress event with the according KeyPressMask. Now whenever we press a key, the window will be closed.

Test your skills!
Now that you have a faint idea of how all of this works, we encourage you to make the hook handlers. Whenever the:

ESC key is pressed, your window should close.
window is resized, you should print something in your terminal.
the red cross is clicked, your window should close.
you press a key longer than x seconds, you should print something in your terminal.
mouse enters the window, you should print Hello! in your terminal, when it leaves, you should print Bye!.

Hooks
Table of contents
Introduction
Hooking into key events
Hooking into mouse events
Test your skills!
In computer programming, the term hooking covers a range of techniques used to alter or augment the behaviour of an operating system, of applications, or of other software components by intercepting function calls or messages or events passed between software components. Code that handles such intercepted function calls, events or messages is called a hook.

Introduction
Hooking is used for many purposes, including debugging and extending functionality. Examples might include intercepting keyboard or mouse event messages before they reach an application, or intercepting operating system calls in order to monitor behavior or modify the function of an application or another component. It is also widely used in benchmarking programs, for example to measure frame rate in 3D games, where the output and input is done through hooking.

Simply put, it is therefore not weird that hooking is the backbone of MiniLibX.

Hooking into key events
Hooking may sound difficult, but it really is not. Let’s take a look shall we?

#include <mlx.h>
#include <stdio.h>

typedef struct	s_game {
	void	*mlx;
	void	*win;
}				t_game;

int	key_hook(int keycode, t_game *game)
{
	printf("Hello from key_hook!\n");
	return (0);
}

int	main(void)
{
	t_game	game;

	game.mlx = mlx_init();
	game.win = mlx_new_window(game.mlx, 640, 480, "Hello world!");
	mlx_key_hook(game.win, key_hook, &game);
	mlx_loop(game.mlx);
}

We have now registered a function that will print a message whenever we press a key. As you can see, we register a hook function with mlx_key_hook. However in the background it simply calls the function mlx_hook with the appropriate X11 event types. We will discuss this in the next chapter.

Hooking into mouse events


Also, you can hook mouse events.

mlx_mouse_hook(game.win, mouse_hook, &game);

Mouse code for MacOS:

Left click: 1
Right click: 2
Middle click: 3
Scroll up: 4
Scroll down : 5
Test your skills!
Now that you have a faint idea of what hooks are, we will allow you to create a few of your own. Create hook handlers that whenever:

a key is pressed, it will print the key code in the terminal.
the mouse if moved, it will print the current position of that mouse in the terminal.
a mouse is pressed, it will print the angle at which it moved over the window to the terminal.

Loops
Table of contents
Introduction
Hooking into loops
Test your skills!
Introduction
Now that you finally understand the basics of the MiniLibX library, we will start with drawing a tiny animation in the window. For this we will be using two new functions, namely mlx_loop and mlx_loop_hook.

Loops are a feature of MiniLibX where it will continue to call your hook registered in mlx_loop_hook to render new frames, which you obviously have to pass to the window yourself.

Hooking into loops
To initiate a loop, we call the mlx_loop function with the mlx instance as only parameter, take a look:

#include <mlx.h>

int	main(void)
{
	void	*mlx;

	mlx = mlx_init();
	mlx_loop(mlx);
}

This will do nothing of course as we have no loop hook registered, therefore we will not be able to write anything to our frame.

To do this, you will have to create a new window and use the mutations that we described in the Getting Started chapter. We assume that your knowledge of that is proficient and that you will be able to pass your parameters accordingly. An example whiteboarded version of it could look as follows:

#include <mlx.h>

int	render_next_frame(void *YourStruct);

int	main(void)
{
	void	*mlx;

	mlx = mlx_init();
	mlx_loop_hook(mlx, render_next_frame, YourStruct);
	mlx_loop(mlx);
}

Now for each frame it requires, it will call the function render_next_frame with the parameter YourStruct. This will persist through multiple calls if it is a pointer, so use that to your advantage!

Test your skills!
Now that you understand how to register your own rendering function, we suggest that you create the following renderers:

Render a moving rainbow that shifts through all colors (screen turns red, becomes green and then becomes blue, then starts all over again).
Create a circle that you can move accross your screen using your WASD keys.

Images
Table of contents
Introduction
Reading images
Test your skills!
Introduction
Images are a very important tool in MiniLibX in order to embrace its full potential. These functions will allow you to read files directly into a image object. This is very useful for textures or sprites of course.

Reading images
To read from a file to a image object, you need either the XMP or PNG format. In order to read we can call the functions mlx_xpm_file_to_image and mlx_png_file_to_image accordingly. Do mind that mlx_png_file_to_image currently leaks memory. Both functions accept exactly the same parameters and their usage is identical.

Now, lets read from an image, shall we?

#include <mlx.h>

int	main(void)
{
	void	*mlx;
	void	*img;
	char	*relative_path = "./test.xpm";
	int		img_width;
	int		img_height;

	mlx = mlx_init();
	img = mlx_xpm_file_to_image(mlx, relative_path, &img_width, &img_height);
}

If the img variable is equal to NULL, it means that the image reading has failed. It will also set the img_width and img_height accordingly, which is ideal when reading sprites.

Test your skills!
Now that you know how to read from files, lets get started on making more graphical stuff ;). Create the following programs:

Import a cursor of your choice and allow it to roam within the window freely.
Import a texture and replicate it accross your entire window.

Sync
Table of contents
What is sync?
Using sync
Test your skills!
What is sync?
As mentioned before, you could manage your own frame buffering with MLX, however this is fairly tedious and time consuming. Besides, we use more memory and our frames need to constantly be FULLY updated. This is not very efficient hence we need to avoid it at all costs.

From the 2020 MLX version, you will be able to synchronize your own frames, which should make the hacky multiple images for screen buffering no longer required.

Using sync
We have three defines that we need to understand first:

#define MLX_SYNC_IMAGE_WRITABLE		1
#define MLX_SYNC_WIN_FLUSH_CMD		2
#define MLX_SYNC_WIN_CMD_COMPLETED	3

int	mlx_sync(int cmd, void *ptr);

mlx_sync ought to be called with the defined command codes. The first one, MLX_SYNC_IMAGE_WRITABLE will buffer all subsequential calls to an image (ptr is a pointer to the MLX image object). If you want to propagate changes, you will have to flush the window in which the image is present, using MLX_SYNC_WIN_FLUSH_CMD and the window you want to flush as a ptr.

Test your skills!
Now that you have a faint idea of what mlx_sync can do, grab your previous tiny circle-game that you made in loops and add mlx_sync to your rendering!