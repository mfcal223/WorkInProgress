/* PROJECT WORKFLOW */

1. Initialization Phase

Program starts by checking command line arguments (must be 2: program name and map file)
Validates map file extension (must be .ber)
Initializes game structure (t_init) with default values

Main game structure includes:
- MLX connection
- Textures and images
- Map image
- Player position (ship)
- Game state (moves, collectibles, etc.)

2. Map Loading and Validation

Reads map file line by line
Creates a linked list structure to store the map
Validates map requirements:
Must be rectangular
Must be surrounded by walls
Must contain:
One player (P)
At least one collectible (C)
One exit (E)
Must be possible to reach all collectibles and exit

3. Graphics Initialization

Initializes MLX42 library
Loads all required textures:
- - Ocean (background)
- Wall
- Ship (player) with different directions
- Collectibles
- Exit (closed and open states)
- Shark (enemy)
- Converts textures to images for display

4. Game Loop

Main game loop starts with mlx_loop()
Handles keyboard input through ft_key_press:
- Arrow keys for movement
- ESC to exit
- Updates game state:
- Player position
- Collectibles collected
- Move counter
- Win/lose conditions

5. Movement and Collision System

Player movement in four directions
Checks for collisions with:
Walls (blocked)
Collectibles (collected)
Exit (only usable when all collectibles are collected)
Updates player sprite direction based on movement

6. Game State Management

Tracks:
Number of moves
Number of collectibles collected
Game status (playing/won/lost)
Player direction
Walking state

7. Memory Management and Cleanup

Frees allocated memory for:
Map image
Textures
Images
Game structures
Proper cleanup on game exit

8. Error Handling

Validates input parameters
Checks for file errors
Validates map format and content
Handles texture loading errors
Manages memory allocation failures
This structure allows you to organize your own project into similar sections:

Create the basic structure and initialization functions
Implement map reading and validation
Set up graphics and window management
Create the game loop and input handling
Implement movement and collision detection
Add game state tracking
Implement proper memory management
Add error handling throughout the program
The project uses the MLX42 library for graphics, which is an improved version of the original MLX library, providing better performance and cross-platform compatibility.

/* ########################################################################## */

/* HOW FUNCTIONS INTERCONNECT */
Let me analyze the main functions and their relationships in the so_long project. I'll group them by their main purpose and explain how they interact:

Main Program Flow
Code
main() → ft_start_map() → ft_map() → ft_mlx_init()

main: Entry point that validates arguments and initiates the game
ft_start_map: Orchestrates the initialization process
ft_map: Sets up the map structure and validates it
ft_mlx_init: Initializes the MLX window and graphics
Initialization Functions
Code
ft_initialize_game()
├── ft_init_txts()  // Loads textures
└── ft_init_imgs()  // Converts textures to images
These functions handle the initial setup of game structures and graphics.

Map Processing Chain
Code
ft_map_init()
├── ft_check_empty_line()  // Validates map lines
├── ft_add_line()         // Adds new line to map structure
└── ft_status_map()       // Creates map status arrays
These functions work together to read and validate the map file.

Map Validation Chain
Code
ft_flood()
├── ft_fill()            // Flood fill algorithm
├── ft_check_borders()   // Validates map borders
├── ft_check_form()      // Checks map shape
└── ft_check_failed()    // Final validation check
These functions ensure the map is valid and solvable.

Game Object Management
Code
ft_find_ship()      // Locates player position
ft_count_obj()      // Counts game objects
ft_objs_init()      // Initializes object counters
These functions handle game object tracking and initialization.

Movement and Input System
Code
ft_key_press()
├── ft_move_ship_[direction]()  // Handle movement in specific direction
├── ft_ship_go_[direction]()    // Animate movement
└── ft_key_check()             // Validate movement possibility
These functions handle player input and movement.

Drawing and Display
Code
ft_drawing_map()
├── ft_drawing_imgs()   // Draws game objects
└── ft_drawing_ship()   // Draws player character
These functions handle the visual representation of the game.

Memory Management
Code
ft_free_all()
├── ft_free_stack()    // Frees map linked list
├── ft_free_txt()      // Frees textures
├── ft_free_img()      // Frees images
└── ft_free_status()   // Frees status arrays
These functions handle memory cleanup.

Key Function Dependencies and Workflow:

Initialization Flow:

Code
main()
└── ft_start_map()
    ├── ft_initialize_game()
    ├── ft_map()
    │   ├── ft_map_init()
    │   └── ft_status_map()
    ├── ft_find_ship()
    ├── ft_flood()
    └── ft_mlx_init()
        ├── ft_init_txts()
        ├── ft_init_imgs()
        └── ft_drawing_map()

Game Loop Flow:

mlx_loop()
└── ft_key_press()
    ├── ft_find_ship()
    ├── ft_key_check()
    └── ft_move_ship_[direction]()
        └── ft_ship_go_[direction]()
Validation Flow:


ft_check_failed()
├── ft_check_obj()
├── ft_check_obj_nbr()
├── ft_check_form()
└── ft_check_borders()

Critical Interconnections:

1. The t_init structure is the central image structure that connects all functions:

Contains game state
Holds graphics resources
Stores map information
Tracks player position and collectibles

2. Map validation is a multi-step process:

Initial reading and structure creation
Shape and border validation
Path validation using flood fill
Object count validation

3. Movement system depends on:

Current map state
Player position
Collision detection
Game state (collectibles, exit status)

4. Graphics system relies on:

Properly loaded textures
Converted images
Valid map image
Current game state

5. This interconnected system ensures that:

The game initializes properly
The map is valid and solvable
Player movement is correct and tracked
Graphics are properly displayed
Memory is managed correctly
Game state is consistently maintained

/* can you describe in more detail what the validation involves? what characteristics of the input are being validated? what does the initialization process involves? */

1) Main Function (Entry Point) Validation:
C
int main(int argc, char **argv)
{
    // 1. Validates number of arguments
    if (argc != 2)
    {
        ft_map_error(ERR_INIT);
        return (1);
    }

    // 2. Validates file extension
    if (ft_check_ber(argv[1]) == FAILURE)
    {
        ft_map_error(ERR_FILE);
        return (FAILURE);
    }

    // 3. Starts map initialization and validation process
    if (ft_start_map(argv[1]) == FAILURE)
        return (FAILURE);
}
Key Validations in main:

Must have exactly 2 arguments (program name and map file)
Map file must have .ber extension
Map file must be accessible and valid

2) ft_start_map Function (Initialization Process):
C
int ft_start_map(char *path)
{
    t_init *game;

    // 1. Allocates and initializes game structure
    game = ft_calloc(sizeof(t_init), 1);
    game = ft_initialize_game(game);
    game->path = path;

    // 2. Sets up map structure and validates format
    if (ft_map(&game) == FAILURE)
        return (FAILURE);

    // 3. Finds player starting position
    game = ft_find_ship(game);

    // 4. Validates map is solvable using flood fill
    game = ft_flood(game);

    // 5. Final validation of map requirements
    if (ft_check_failed(game, ft_count_obj(game->map)) == FAILURE)
    {
        ft_free_all(game, 1);
        return (FAILURE);
    }

    // 6. Initializes MLX and graphics
    ft_mlx_init(game);
}
Key Steps in Initialization:

Allocates game structure
Initializes all variables to default values
Sets up map image structures
Validates map solvability
Initializes graphics system

3) ft_map Function (Map Structure and Validation):
C
int ft_map(t_init **game)
{
    t_init *tmp;

    tmp = *game;
    // 1. Reads and creates map structure
    tmp->map = ft_map_init(tmp);
    if (!tmp->map)
        return (FAILURE);

    // 2. Gets map dimensions
    tmp->size.x = ft_map_x(tmp->map);
    tmp->size.y = ft_map_y(tmp->map);

    // 3. Creates two status arrays for map validation
    tmp->status_a = ft_status_map(tmp);
    tmp->status_b = ft_status_map(tmp);
}

-.-.-.-.-.--.-.-.-.-.--.-.-.-.-.--.-.-.-.-.-

The map validation includes multiple checks:

1. File Format Validation:

File must exist and be readable
Must have .ber extension
No empty lines in the map

2. Map Structure Validation:

Code
// Valid map example:
1111111111
10C0000001
1000P00E01
1111111111
Map must be rectangular (all rows same length)
Must be surrounded by walls ('1')
Must contain:
One player ('P')
At least one collectible ('C')
One exit ('E')
Valid path characters ('0' for empty space)
Map Content Requirements:

Only valid characters allowed: '0', '1', 'C', 'E', 'P'
Must have exactly one player starting position
Must have at least one collectible
Must have exactly one exit
Must be possible to reach all collectibles and the exit
Path Validation (Flood Fill):

Uses flood fill algorithm to verify:
All collectibles are reachable from player position
Exit is reachable from player position
This ensures the map is solvable

-.-.-.-.-.--.-.-.-.-.--.-.-.-.-.--.-.-.-.-.--.-.-.-.-.-

The initialization process involves:

Game Structure Setup:

Allocates memory for game structure
Initializes all counters and flags to zero
Sets up pointers for various components

Map Setup:

Creates linked list structure for map storage
Creates two status arrays for validation
Sets up coordinate system

Resource Initialization:

Prepares for texture loading
Sets up image handling
Initializes player position

Graphics Setup:

Initializes MLX window
Loads required textures
Creates image instances
Sets up display parameters

Error handling is integrated throughout the process:

Memory allocation failures
File reading errors
Invalid map configurations
Resource loading failures



========================================================================
INC FOLDER

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   colors.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-07-02 11:01:12 by sternero          #+#    #+#             */
/*   Updated: 2024-07-02 11:01:12 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef COLORS_H
# define COLORS_H

// To reset the color of the text to the default color (white):

# define RESET		"\033[0m"    // expample: printf(RESET "Hello World\n");

// To print the texts in diferent colors:

# define RED		"\033[0;31m" // expample: printf(RED "Hello World\n");
# define GREEN		"\033[0;32m" // expample: @echo -e "$(GREEN)Hello World"
# define YELLOW		"\033[0;33m" 
# define BLUE		"\033[0;34m" 
# define MAGENTA	"\033[0;35m" 
# define CYAN		"\033[0;36m" 
# define WHITE		"\033[0;37m"
# define ORANGE 	"\033[1;31m"

// To print the bold texts in diferent colors:

# define BDBLACK 	"\033[1;30m" // expample: printf(BDBLACK "Hello World\n");
# define BDRED 		"\033[1;31m" // expample: @echo -e "$(BDRED)Hello World"
# define BDGREEN 	"\033[1;32m"
# define BDYELLOW 	"\033[1;33m"
# define BDBLUE 	"\033[1;34m"
# define BDMAGENTA 	"\033[1;35m"
# define BDCYAN 	"\033[1;36m"
# define BDWHITE 	"\033[1;37m"

// To print the underlined texts in diferent colors:

# define ULRED 		"\033[4;31m" // expample: printf(ULRED "Hello World\n");
# define ULGREEN 	"\033[4;32m" // expample: @echo -e "$(ULGREEN)Hello World"
# define ULYELLOW 	"\033[4;33m"
# define ULBLUE 	"\033[4;34m"
# define ULMAGENTA 	"\033[4;35m"
# define ULCYAN 	"\033[4;36m"
# define ULWHITE 	"\033[4;37m"

// To print lines, shades, blocks and arrows:

# define EQLIN 		"\u2550" // EQUAL LINE     ═══════════════════
# define LSHADE 	"\u2591" // LIGHT SHADE    ░░░░░░░░░░░░░░░░░░░
# define MSHADE 	"\u2592" // MEDIUM SHADE   ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
# define HSHADE 	"\u2593" // HEAVY SHADE    ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
# define FBLOCK 	"\u2588" // FULL BLOCK     ███████████████████
# define EBLOCK 	"\u258d" // EIGHTH BLOCK   ▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍▍
# define ARROWRG 	"\u2911" // RIGHT ARROW    ⤑⤑⤑⤑⤑⤑⤑⤑⤑⤑⤑⤑⤑⤑

#endif


/* */ 

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   so_long.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-07-14 09:35:56 by sternero          #+#    #+#             */
/*   Updated: 2024-07-14 09:35:56 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SO_LONG_H           // If the header file has not been included.
# define SO_LONG_H          // Define the header file.

# include <stdio.h>         // Standard input/output definitions.
# include <fcntl.h>         // File control options. Used for open().
# include <unistd.h>        // Used for read() and close().
# include <stdlib.h>        // General utilities.
# include <stdarg.h>        // VA. To use va_list, va_start, va_arg, va_end.
# include "../ft_printf/ft_printf.h"        // Custom printf function.
# include "../libft/libft.h"                // Custom library functions.
# include "../MLX42/include/MLX42/MLX42.h"  // MLX42 library.
# include "./MLX42/MLX42.h"                 // MLX42 library.

// *** Name of the game. ***

# define NAME "so_long"     // Name of the executable.
# define TITRE "So Long"    // Title of the window.

# define TILE_SIZE 32       // Size of the tiles in pixels.
# define IMG_SIZE 48        // Size of the images in pixels.

// *** Window size. ***

# define WIDTH 1920         // Width of the window.
# define HEIGHT 1080        // Height of the window.

# define TRUE 1             // Boolean true. 
# define FALSE 0            // Boolean false.
# define BOOL 			    // Boolean type. Value can be TRUE or FALSE.

// *** Colors for the terminal. ***

# define WHITE "\033[1;37m"     	// White color for the terminal.
# define RED "\033[1;31m"       	// Red color for the terminal.
# define GREEN "\033[1;32m"     	// Green color for the terminal.
# define YELLOW "\033[1;33m"    	// Yellow color for the terminal.
# define DARK_YELLOW "\033[1;93m" 	// Dark yellow color for the terminal.
# define BLUE "\033[1;34m"      	// Blue color for the terminal.
# define DARK_BLUE "\033[1;36m" 	// Dark blue color for the terminal.
# define MAGENTA "\033[1;35m"   	// Magenta color for the terminal.
# define PEACH "\033[1;91m"     	// Peach color for the terminal.
# define CYAN "\033[1;36m"      	// Cyan color for the terminal.
# define PINK "\033[1;95m"      	// Pink color for the terminal.
# define RESET "\033[0m"        	// Reset color for the terminal.
# define SLOW_BLINK "\033[5m"   	// Slow blink for the terminal.

// *** Map elements. ***

# define PLAYER 'P'     // Player character.
# define ENEMY 'X'      // Enemy character.
# define WALL '1'       // Wall character.
# define FLOOR '0'      // Floor character.
# define COLLECT 'C'    // Collectible character.
# define EXIT 'E'       // Exit character.

// *** Error messages. ***

# define ERR_FILE "Invalid name of the map, must be a *.ber file\n"
# define ERR_CHAR "The map contains invalid characters.\n"
# define ERR_MLX "Failed MLX initiation.\n"
# define ERR_MAP "The map was not found or cannot be opened.\n"
# define ERR_INIT "Usage: ./so_long [map.ber].\n"
# define ERR_PLAYER "The map must contain one player (ship), and only one.\n"
# define ERR_COLLEC "The map must contain at least one collectible.\n"
# define ERR_EXIT "The map must contain one exit, and only one.\n"
# define ERR_FORMAT "The map is not rectangular.\n"
# define ERR_BORDER "The map must be surrounded by walls.\n"
# define ERR_LINE "Empty line has been detected in the file.\n"
# define ERR_GENERAL "Map or objects failed.\n"

// *** Return values. ***

# define ERROR -1       // Error return value. Used for error handling.
# define FAILURE 1      // Failure return value. Used for error handling.
# define SUCCESS 0      // Success... 0 is the default return value.

// *** Keycodes for the game. ***

# define LEFT 65361        // ASCII value for the left arrow key.
# define RIGHT 65363       // ASCII value for the right arrow key.
# define DOWN 65364        // ASCII value for the down arrow key.
# define UP 65362          // ASCII value for the up arrow key.

# define ESC 65307         // ASCII value for the 'esc' key.

// *** Paths to graphic imgs. ***

// # define IBEGIN "imgs/begin.xpm"       //Image of the beginning.
// # define IPLAYER "imgs/player.xpm"     //Image of the player.
// # define IENEMY "imgs/enemy.xpm"       //Image of the enemy.
// # define IWALL "imgs/wall.xpm"         //Image of the wall.
// # define IFLOOR "imgs/floor.xpm"       //Image of the floor.
// # define ICOLLECT "imgs/collect.xpm"   //Image of the collectible.
// # define IEXIT "imgs/exit.xpm"         //Image of the exit.

// *** Structure for the textures. ***

typedef struct s_txts
{
	mlx_texture_t	*ocean;
	mlx_texture_t	*wall;
	mlx_texture_t	*collec;
	mlx_texture_t	*exit_c;
	mlx_texture_t	*exit_o;
	mlx_texture_t	*ship;
	mlx_texture_t	*ship_u;
	mlx_texture_t	*ship_d;
	mlx_texture_t	*ship_l;
	mlx_texture_t	*ship_r;
	mlx_texture_t	*shark;
	//mlx_texture_t   *shark_u;
	//mlx_texture_t   *shark_d;
	// mlx_texture_t   *shark_l;
	// mlx_texture_t   *shark_r;
}	t_txts;

//The textures are created to store the texture of the game. The textures 
//are used to give the visual aspect of the objects in the game.

// *** Structure for the images. ***

typedef struct s_images
{
	mlx_image_t		*ocean;
	mlx_image_t		*wall;
	mlx_image_t		*collec;
	mlx_image_t		*exit_c;
	mlx_image_t		*exit_o;
	mlx_image_t		*ship;
	mlx_image_t		*ship_u;
	mlx_image_t		*ship_d;
	mlx_image_t		*ship_l;
	mlx_image_t		*ship_r;
	mlx_image_t		*shark;
	// mlx_image_t		*shark_u;
	// mlx_image_t		*shark_d;
	// mlx_image_t		*shark_l;
	// mlx_image_t		*shark_r;
}	t_images;

//The images are created to store the images of the game. The images are
//the visual objetcs that are displayed in the game.

// *** Structure for the map. ***

typedef struct s_map
{
	char			*map;
	struct s_map	*next;
}	t_map;

//The map is used to store the map of the game. *map store the information
//of the map. *next is used to store the next map. For example, if the player
//goes to the next level. It is not used in this game.

// *** Structure for the cells. ***

typedef struct s_cell
{
	int	ship;
	int	shark;
	int	ocean;
	int	wall;
	int	collec;
	int	exit;
}	t_cell;

//The cells are used to store the information of the cells of the game. 
//For example, if the cell contains a ship, a wall...
//The values are set to 0 or 1 to indicate if the cell contains the object.

// *** Structure for the key codes. ***

typedef struct s_key_press
{
	int	key;
}	t_key_press;

//The key press is used to store the key pressed by the player.

// *** Structure for the position. ***

typedef struct s_coord
{
	int	x;
	int	y;
}	t_coord;

//The coord structure is used to store the position of the objects in the game.

// *** Structure for the game. ***

typedef struct s_init
{
	mlx_t			*mlx;			// Connection to the graphic display.
	t_txts			txts;			// Textures of the game.
	t_images		imgs;			// Images of the game.
	t_cell			cell;			// Object of the game.
	t_map			*map;			// Map of the game.
	t_coord			ship;			// Position of the player.
	t_coord			shark;			// Position of the enemy.
	t_coord			size;			// Size in pixels of the window.
	char			**status_a;		// Matrix of the map.
	char			**status_b;		// Matrix of the map.
	char			*path;			// Path to the map.
	int				moves;			// Number of moves.
	int				counter;		// Number of collectibles.
	int				collec;			// Number of collectibles.
	int				c;			// Collectibles collected.	
	int				flag;			// 0 = game, 1 = win, 2 = lose
	char			course;			// Direction of the player.
	bool			walking;		// Walking or not.
}	t_init;

//The game structure is used to store the information of the game.
//	*mlx is used to store the connection to the display.
//	textures is used to store the textures of the game.
//	images is used to store the images of the game.
//	cell is used to store the information of the cells of the game.
//	*map is used to store the map of the game.
//	ship is used to store the position of the ship, the player.
//	path is used to store the path of the map.
//	moves is used to store the number of moves of the player.
//	counter is used to store the number of collectibles.
//	collec is used to store the number of collectibles.
//	flag is used to store the flag of the game. 0 = game, 1 = win, 2 = lose.
//	course is used to store the direction of the player.
//	walking is used to store if the player is walking or not.

// *** Function prototypes. ***

// *** ft_cells.c ***

t_init		**ft_fill(char **stat, t_coord size, t_coord now, t_init **game);
t_init		*ft_flood(t_init *game);

// *** ft_check_game.c ***

int			ft_check_obj(t_cell checked, t_cell objects);
int			ft_check_obj_nbr(t_cell objects);
int			ft_check_form(t_init *game);
int			ft_check_borders(t_init *game);

// *** ft_check_tools.c ***

int			ft_check_failed(t_init *game, t_cell objects);
int			ft_check_ber(char *file);
void		ft_check_empty_line(t_init *game, char *line);
t_init		**ft_check_cell(t_init	**game, char check);
int			ft_key_check(t_init *game);

// *** ft_drawing_moves.c ***

void		ft_ship_go_up(t_init *game, t_coord p, int step);
void		ft_ship_go_down(t_init *game, t_coord p, int step);
void		ft_ship_go_right(t_init *game, t_coord p, int step);
void		ft_ship_go_left(t_init *game, t_coord p, int step);

// *** ft_drawing_tools.c ***

t_map		*ft_add_line(char *line);
void		ft_last_line(t_init *game, t_map *new);
void		ft_drawing_map(t_init *game);
void		ft_drawing_imgs(t_init *game, char img, t_coord p);
void		ft_drawing_ship(t_init *game, t_coord p);

// *** ft_free_tools.c ***

void		ft_free_all(t_init *game, int error);
void		ft_free_stack(t_map **stack);
void		ft_free_txt(t_init **game);
void		ft_free_img(t_init **game);
char		**ft_free_status(char **status, int len);

// *** ft_initialize.c ***

t_init		*ft_initialize_game(t_init *init);
int			ft_start_map(char *path);
t_map		*ft_map_init(t_init *game);
void		ft_init_txts(t_init *game);
void		ft_init_imgs(t_init *game);

// *** ft_materials.c ***

t_init		*ft_find_ship(t_init *ship);
void		ft_objs_init(t_cell *obj);
t_cell		ft_count_obj(t_map *map);

// *** ft_mlx_init.c ***

void		ft_mlx_init(t_init *gm);

// *** ft_moves.c ***

void		ft_move_ship_right(t_init *game, int y, int x);
void		ft_move_ship_left(t_init *game, int y, int x);
void		ft_move_ship_up(t_init *game, int y, int x);
void		ft_move_ship_down(t_init *game, int y, int x);

// *** ft_tools.c ***

void		ft_map_error(char *str);
int			ft_map_x(t_map *width);
int			ft_map_y(t_map *height);
void		ft_game_over_(void);

// *** so_long.c ***

char		**ft_status_map(t_init *game);
void		ft_key_press(struct mlx_key_image key_image, void *date);
int			ft_map(t_init **game);
//int			main(int argc, char **argv);

#endif

/* */

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   so_long_bonus.h                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-07-14 09:35:56 by sternero          #+#    #+#             */
/*   Updated: 2024-07-14 09:35:56 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SO_LONG_BONUS_H           // If the header file has not been included.
# define SO_LONG_BONUS_H          // Define the header file.

# include <stdio.h>         // Standard input/output definitions.
# include <fcntl.h>         // File control options. Used for open().
# include <unistd.h>        // Used for read() and close().
# include <stdlib.h>        // General utilities.
# include <stdarg.h>        // VA. To use va_list, va_start, va_arg, va_end.

# include "../ft_printf/ft_printf.h"        // Custom printf function.
# include "../libft/libft.h"                // Custom library functions.
# include "../MLX42/include/MLX42/MLX42.h"  // MLX42 library.
# include "./MLX42/MLX42.h"                 // MLX42 library.

// *** Name of the game. ***

# define NAME "so_long"     // Name of the executable.
# define TITRE "So Long"    // Title of the window.

# define TILE_SIZE 32       // Size of the tiles in pixels.
# define IMG_SIZE 48        // Size of the images in pixels.

// *** Window size. ***

# define WIDTH 1920         // Width of the window.
# define HEIGHT 1080        // Height of the window.

# define TRUE 1             // Boolean true. 
# define FALSE 0            // Boolean false.
# define BOOL			    // Boolean type. Value can be TRUE or FALSE.

// *** Colors for the terminal. ***

# define WHITE "\033[1;37m"     	// White color for the terminal.
# define RED "\033[1;31m"       	// Red color for the terminal.
# define GREEN "\033[1;32m"     	// Green color for the terminal.
# define YELLOW "\033[1;33m"    	// Yellow color for the terminal.
# define DARK_YELLOW "\033[1;93m" 	// Dark yellow color for the terminal.
# define BLUE "\033[1;34m"      	// Blue color for the terminal.
# define DARK_BLUE "\033[1;36m" 	// Dark blue color for the terminal.
# define MAGENTA "\033[1;35m"   	// Magenta color for the terminal.
# define PEACH "\033[1;91m"     	// Peach color for the terminal.
# define CYAN "\033[1;36m"      	// Cyan color for the terminal.
# define PINK "\033[1;95m"      	// Pink color for the terminal.
# define RESET "\033[0m"        	// Reset color for the terminal.
# define SLOW_BLINK "\033[5m"   	// Slow blink for the terminal.

// *** Map elements. ***

# define PLAYER 'P'     // Player character.
# define ENEMY 'X'      // Enemy character.
# define WALL '1'       // Wall character.
# define FLOOR '0'      // Floor character.
# define COLLECT 'C'    // Collectible character.
# define EXIT 'E'       // Exit character.

// *** Error messages. ***

# define ERR_FILE "Invalid name of the map, must be a *.ber file\n"
# define ERR_CHAR "The map contains invalid characters.\n"
# define ERR_MLX "Failed MLX initiation.\n"
# define ERR_MAP "The map was not found or cannot be opened.\n"
# define ERR_INIT "Usage: ./so_long [map.ber].\n"
# define ERR_PLAYER "The map must contain one player (ship), and only one.\n"
# define ERR_COLLEC "The map must contain at least one collectible.\n"
# define ERR_EXIT "The map must contain one exit, and only one.\n"
# define ERR_FORMAT "The map is not rectangular.\n"
# define ERR_BORDER "The map must be surrounded by walls.\n"
# define ERR_LINE "Empty line has been detected in the file.\n"
# define ERR_GENERAL "Map or objects failed.\n"
// *** Return values. ***

# define ERROR -1       // Error return value. Used for error handling.
# define FAILURE 1      // Failure return value. Used for error handling.
# define SUCCESS 0      // Success... 0 is the default return value.

// *** Keycodes for the game. ***

# define LEFT 65361        // ASCII value for the left arrow key.
# define RIGHT 65363       // ASCII value for the right arrow key.
# define DOWN 65364        // ASCII value for the down arrow key.
# define UP 65362          // ASCII value for the up arrow key.

# define ESC 65307         // ASCII value for the 'esc' key.

// *** Paths to graphic imgs. ***

// # define IBEGIN "imgs/begin.xpm"       //Image of the beginning.
// # define IPLAYER "imgs/player.xpm"     //Image of the player.
// # define IENEMY "imgs/enemy.xpm"       //Image of the enemy.
// # define IWALL "imgs/wall.xpm"         //Image of the wall.
// # define IFLOOR "imgs/floor.xpm"       //Image of the floor.
// # define ICOLLECT "imgs/collect.xpm"   //Image of the collectible.
// # define IEXIT "imgs/exit.xpm"         //Image of the exit.

// *** Structure for the textures. ***

typedef struct s_txts
{
	mlx_texture_t	*ocean;
	mlx_texture_t	*wall;
	mlx_texture_t	*collec;
	mlx_texture_t	*exit_c;
	mlx_texture_t	*exit_o;
	mlx_texture_t	*ship;
	mlx_texture_t	*ship_u;
	mlx_texture_t	*ship_d;
	mlx_texture_t	*ship_l;
	mlx_texture_t	*ship_r;
	mlx_texture_t	*shark;
	//mlx_texture_t   *shark_u;
	//mlx_texture_t   *shark_d;
	// mlx_texture_t   *shark_l;
	// mlx_texture_t   *shark_r;
}	t_txts;

//The textures are created to store the texture of the game. The textures 
//are used to give the visual aspect of the objects in the game.

// *** Structure for the images. ***

typedef struct s_images
{
	mlx_image_t		*ocean;
	mlx_image_t		*wall;
	mlx_image_t		*collec;
	mlx_image_t		*exit_c;
	mlx_image_t		*exit_o;
	mlx_image_t		*ship;
	mlx_image_t		*ship_u;
	mlx_image_t		*ship_d;
	mlx_image_t		*ship_l;
	mlx_image_t		*ship_r;
	mlx_image_t		*shark;
	// mlx_image_t		*shark_u;
	// mlx_image_t		*shark_d;
	// mlx_image_t		*shark_l;
	// mlx_image_t		*shark_r;
}	t_images;

//The images are created to store the images of the game. The images are
//the visual objetcs that are displayed in the game.

// *** Structure for the map. ***

typedef struct s_map
{
	char			*map;
	struct s_map	*next;
}	t_map;

//The map is used to store the map of the game. *map store the information
//of the map. *next is used to store the next map. For example, if the player
//goes to the next level. It is not used in this game.

// *** Structure for the cells. ***

typedef struct s_cell
{
	int	ship;
	int	shark;
	int	ocean;
	int	wall;
	int	collec;
	int	exit;
}	t_cell;

//The cells are used to store the information of the cells of the game. 
//For example, if the cell contains a ship, a wall...
//The values are set to 0 or 1 to indicate if the cell contains the object.

// *** Structure for the key codes. ***

typedef struct s_key_press
{
	int	key;
}	t_key_press;

//The key press is used to store the key pressed by the player.

// *** Structure for the position. ***

typedef struct s_coord
{
	int	x;
	int	y;
}	t_coord;

//The coord structure is used to store the position of the objects in the game.

// *** Structure for the game. ***

typedef struct s_init
{
	mlx_t			*mlx;			// Connection to the graphic display.
	t_txts			txts;			// Textures of the game.
	t_images		imgs;			// Images of the game.
	t_cell			cell;			// Object of the game.
	t_map			*map;			// Map of the game.
	t_coord			ship;			// Position of the player.
	t_coord			shark;			// Position of the enemy.
	t_coord			size;			// Size in pixels of the window.
	char			**status_a;		// Matrix of the map.
	char			**status_b;		// Matrix of the map.
	char			*path;			// Path to the map.
	int				moves;			// Number of moves.
	int				counter;		// Number of collectibles.
	int				collec;			// Number of collectibles.
	int				c;				// Collectibles collected.	
	int				flag;			// 0 = game, 1 = win, 2 = lose
	char			course;			// Direction of the player.
	bool			walking;		// Walking or not.
}	t_init;

//The game structure is used to store the information of the game.
//	*mlx is used to store the connection to the display.
//	textures is used to store the textures of the game.
//	images is used to store the images of the game.
//	cell is used to store the information of the cells of the game.
//	*map is used to store the map of the game.
//	ship is used to store the position of the ship, the player.
//	path is used to store the path of the map.
//	moves is used to store the number of moves of the player.
//	counter is used to store the number of collectibles.
//	collec is used to store the number of collectibles.
//	flag is used to store the flag of the game. 0 = game, 1 = win, 2 = lose.
//	course is used to store the direction of the player.
//	walking is used to store if the player is walking or not.

// *** Function prototypes. ***

// *** ft_cells.c ***

t_init		**ft_fill(char **stat, t_coord size, t_coord now, t_init **game);
t_init		*ft_flood(t_init *game);

// *** ft_check_game.c ***

int			ft_check_obj(t_cell checked, t_cell objects);
int			ft_check_obj_nbr(t_cell objects);
int			ft_check_form(t_init *game);
int			ft_check_borders(t_init *game);

// *** ft_check_tools.c ***

int			ft_check_failed(t_init *game, t_cell objects);
int			ft_check_ber(char *file);
void		ft_check_empty_line(t_init *game, char *line);
t_init		**ft_check_cell(t_init	**game, char check);
int			ft_key_check(t_init *game);

// *** ft_drawing_moves.c ***

void		ft_ship_go_up(t_init *game, t_coord p, int step);
void		ft_ship_go_down(t_init *game, t_coord p, int step);
void		ft_ship_go_right(t_init *game, t_coord p, int step);
void		ft_ship_go_left(t_init *game, t_coord p, int step);

// *** ft_drawing_tools.c ***

t_map		*ft_add_line(char *line);
void		ft_last_line(t_init *game, t_map *new);
void		ft_drawing_map(t_init *game);
void		ft_drawing_imgs(t_init *game, char img, t_coord p);
void		ft_drawing_ship(t_init *game, t_coord p);

// *** ft_free_tools.c ***

void		ft_free_all(t_init *game, int error);
void		ft_free_stack(t_map **stack);
void		ft_free_txt(t_init **game);
void		ft_free_img(t_init **game);
char		**ft_free_status(char **status, int len);

// *** ft_initialize.c ***

t_init		*ft_initialize_game(t_init *init);
int			ft_start_map(char *path);
t_map		*ft_map_init(t_init *game);
void		ft_init_txts(t_init *game);
void		ft_init_imgs(t_init *game);

// *** ft_materials.c ***

t_init		*ft_find_ship(t_init *ship);
void		ft_objs_init(t_cell *obj);
t_cell		ft_count_obj(t_map *map);

// *** ft_mlx_init.c ***

void		ft_mlx_init(t_init *gm);

// *** ft_moves.c ***

void		ft_moves_win(t_init *game);
void		ft_move_ship_right(t_init *game, int y, int x);
void		ft_move_ship_left(t_init *game, int y, int x);
void		ft_move_ship_up(t_init *game, int y, int x);
void		ft_move_ship_down(t_init *game, int y, int x);

// *** ft_tools.c ***

void		ft_map_error(char *str);
int			ft_map_x(t_map *width);
int			ft_map_y(t_map *height);
void		ft_the_end(t_init *game);
void		ft_game_over_(void);

// *** so_long.c ***

char		**ft_status_map(t_init *game);
void		ft_key_press(struct mlx_key_image key_image, void *date);
int			ft_map(t_init **game);
//int			main(int argc, char **argv);

#endif

/*  */ 

SRCS FOLDER

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cells.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-15 08:47:06 by sternero          #+#    #+#             */
/*   Updated: 2024-08-15 08:47:06 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

t_init	**ft_fill(char **stat, t_coord size, t_coord now, t_init **game)
{
	if (now.y < 0 || now.y >= size.y || now.x < 0 || now.x >= size.x
		|| stat[now.y][now.x] == '1' || stat[now.y][now.x] == 'F')
		return (game);
	if (stat[now.y][now.x] == 'E')
	{
		stat[now.y][now.x] = 'F';
		(*game)->cell.exit++;
		return (game);
	}
	game = ft_check_cell(game, stat[now.y][now.x]);
	stat[now.y][now.x] = 'F';
	game = ft_fill(stat, size, (t_coord){now.x - 1, now.y}, game);
	game = ft_fill(stat, size, (t_coord){now.x + 1, now.y}, game);
	game = ft_fill(stat, size, (t_coord){now.x, now.y - 1}, game);
	game = ft_fill(stat, size, (t_coord){now.x, now.y + 1}, game);
	return (game);
}

t_init	*ft_flood(t_init *game)
{
	game->cell.ship = 0;
	game->cell.collec = 0;
	game->cell.exit = 0;
	game = *ft_fill(game->status_b, game->size, game->ship, &game);
	return (game);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_check_game.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-15 10:55:21 by sternero          #+#    #+#             */
/*   Updated: 2024-08-15 10:55:21 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

int	ft_check_obj(t_cell checked, t_cell objects)
{
	if (checked.ship != objects.ship)
		return (FAILURE);
	if (checked.collec != objects.collec)
		return (FAILURE);
	if (checked.exit != objects.exit)
		return (FAILURE);
	return (SUCCESS);
}

int	ft_check_obj_nbr(t_cell objects)
{
	if (objects.ship != 1)
		ft_map_error(ERR_PLAYER);
	if (objects.collec < 1)
		ft_map_error(ERR_COLLEC);
	if (objects.exit != 1)
		ft_map_error(ERR_EXIT);
	return (SUCCESS);
}

int	ft_check_form(t_init *game)
{
	int	i;
	int	j;
	int	l_size;

	j = 0;
	l_size = 0;
	while (game->status_a[j][l_size] != '\n')
		l_size++;
	while (j < game->size.y)
	{
		i = 0;
		while (game->status_a[j][i] != '\n' && game->status_a[j][i] != '\0')
		{
			if (game->status_a[j][i] != '0' && game->status_a[j][i] != WALL
				&& game->status_a[j][i] != 'P' && game->status_a[j][i] != 'C'
				&& game->status_a[j][i] != EXIT)
				return (1);
			i++;
		}
		if (l_size != i)
			return (FAILURE);
		j++;
	}
	return (SUCCESS);
}

int	ft_check_borders(t_init *game)
{
	int	i;
	int	j;

	j = 0;
	while (j < game->size.y)
	{
		i = 0;
		while (game->status_a[j][i] != '\n' && game->status_a[j][i] != '\0')
		{
			if (j == 0 && game->status_a[j][i] != WALL)
				return (FAILURE);
			if (j == game->size.y - 1 && game->status_a[j][i] != WALL)
				return (FAILURE);
			if (j != 0 && (i == 0 || i == game->size.x - 1)
				&& game->status_a[j][i] != WALL)
				return (FAILURE);
			if (j != game->size.y - 1 && (i == 0 || i == game->size.x - 1)
				&& game->status_a[j][i] != WALL)
				return (FAILURE);
			i++;
		}
		j++;
	}
	return (SUCCESS);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_check_tools.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-07 11:48:54 by sternero          #+#    #+#             */
/*   Updated: 2024-08-07 11:48:54 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

int	ft_check_failed(t_init *game, t_cell objects)
{
	int	x;

	x = SUCCESS;
	if (ft_check_obj_nbr(objects) == FAILURE)
		x = FAILURE;
	if (ft_check_obj(game->cell, objects) == FAILURE)
		x = FAILURE;
	if (ft_check_form(game) == FAILURE)
		x = FAILURE;
	if (ft_check_borders(game) == FAILURE)
		x = FAILURE;
	if (x == FAILURE)
	{
		(ft_map_error(ERR_GENERAL));
		return (FAILURE);
	}
	return (SUCCESS);
}

int	ft_check_ber(char *file)
{
	size_t	len;

	len = ft_strlen(file);
	if ((file[len - 4] != '.' || file[len - 3] != 'b'
			|| file[len -2] != 'e' || file[len -1] != 'r'))
		return (FAILURE);
	return (SUCCESS);
}

void	ft_check_empty_line(t_init *game, char *line)
{
	t_map	*new;

	if (line[0] == '\n')
	{
		ft_map_error(ERR_LINE);
		free(line);
		exit(FAILURE);
	}
	new = ft_add_line(line);
	ft_last_line(game, new);
	free(line);
}

t_init	**ft_check_cell(t_init	**game, char check)
{
	if (check == 'C')
	{
		(*game)->cell.collec++;
		(*game)->collec++;
	}
	if (check == 'P')
		(*game)->cell.ship++;
	if (check == 'E')
		(*game)->cell.exit++;
	return (game);
}

int	ft_key_check(t_init *game)
{
	if (game->status_a[game->ship.y - 1][game->ship.x] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_UP))
		return (1);
	if (game->status_a[game->ship.y + 1][game->ship.x] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_DOWN))
		return (2);
	if (game->status_a[game->ship.y][game->ship.x - 1] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_LEFT))
		return (3);
	if (game->status_a[game->ship.y][game->ship.x + 1] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_RIGHT))
		return (4);
	if (mlx_is_key_down(game->mlx, MLX_KEY_ESCAPE))
		return (5);
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_drawing_moves.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-16 13:27:50 by sternero          #+#    #+#             */
/*   Updated: 2024-08-16 13:27:50 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

void	ft_ship_go_up(t_init *game, t_coord p, int step)
{
	mlx_delete_image(game->mlx, game->imgs.ship);
	if (step % 2 == 0 && game->imgs.ship_u != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_u,
			p.x * 64, p.y * 64);
	else if (game->imgs.ship_u != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_u,
			p.x * 64, p.y * 64);
}

void	ft_ship_go_down(t_init *game, t_coord p, int step)
{
	mlx_delete_image(game->mlx, game->imgs.ship);
	if (step % 2 == 0 && game->imgs.ship_d != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_d,
			p.x * 64, p.y * 64);
	else if (game->imgs.ship_d != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_d,
			p.x * 64, p.y * 64);
}

void	ft_ship_go_right(t_init *game, t_coord p, int step)
{
	mlx_delete_image(game->mlx, game->imgs.ship);
	if (step % 2 == 0 && game->imgs.ship_r != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_r,
			p.x * 64, p.y * 64);
	else if (game->imgs.ship_r != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_r,
			p.x * 64, p.y * 64);
}

void	ft_ship_go_left(t_init *game, t_coord p, int step)
{
	mlx_delete_image(game->mlx, game->imgs.ship);
	if (step % 2 == 0 && game->imgs.ship_l != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_l,
			p.x * 64, p.y * 64);
	else if (game->imgs.ship_l != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_l,
			p.x * 64, p.y * 64);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_drawing_tools.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-07 08:05:56 by sternero          #+#    #+#             */
/*   Updated: 2024-08-07 08:05:56 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

t_map	*ft_add_line(char *line)
{
	t_map	*new;

	new = malloc(sizeof(t_map));
	if (!new)
		return (NULL);
	new->map = ft_strdup(line);
	if (!new->map)
	{
		free(new);
		return (NULL);
	}
	new->next = NULL;
	return (new);
}

void	ft_last_line(t_init *game, t_map *new)
{
	t_map	*last;

	last = game->map;
	if (!last)
		game->map = new;
	else
	{
		while (last->next)
			last = last->next;
		last->next = new;
	}
}

void	ft_drawing_map(t_init *game)
{
	t_coord	coord;
	int		j;
	int		i;

	j = 0;
	while (j < game->size.y)
	{
		i = 0;
		while (game->status_a[j][i] != '\n' && game->status_a[j][i] != '\0')
		{
			coord.x = i;
			coord.y = j;
			ft_drawing_imgs(game, game->status_a[j][i], coord);
			i++;
		}
		j++;
	}
	ft_drawing_ship(game, game->ship);
}

void	ft_drawing_imgs(t_init *game, char img, t_coord p)
{
	if (img == '1' && game->imgs.wall != NULL)
		mlx_image_to_window(game->mlx, game->imgs.wall, p.x * 64, p.y * 64);
	if (img != '1' && game->imgs.ocean != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ocean, p.x * 64, p.y * 64);
	if (img == 'P')
	{
		ft_drawing_ship(game, p);
		return ;
	}
	if (img == 'C' && game->imgs.collec != NULL)
		mlx_image_to_window(game->mlx, game->imgs.collec, p.x * 64, p.y * 64);
	if (img == 'E' && game->imgs.exit_c != NULL)
		mlx_image_to_window(game->mlx, game->imgs.exit_c, p.x * 64, p.y * 64);
}

void	ft_drawing_ship(t_init *game, t_coord p)
{
	if (game->course == 'U' && game->counter > 0)
		ft_ship_go_up(game, p, game->counter);
	else if (game->course == 'D' && game->counter > 0)
		ft_ship_go_down(game, p, game->counter);
	else if (game->course == 'R' && game->counter > 0)
		ft_ship_go_right(game, p, game->counter);
	else if (game->course == 'L' && game->counter > 0)
		ft_ship_go_left(game, p, game->counter);
	else
		mlx_image_to_window(game->mlx, game->imgs.ship, p.x * 64, p.y * 64);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_free_tools.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-14 09:56:18 by sternero          #+#    #+#             */
/*   Updated: 2024-08-14 09:56:18 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

void	ft_free_all(t_init *game, int error)
{
	if (error == 2)
	{
		ft_free_stack(&game->map);
		free(game);
	}
	if (error == 1)
	{
		game->status_a = ft_free_status(game->status_a, game->size.y);
		ft_free_stack(&game->map);
		free(game);
	}
	if (error == 0)
	{
		game->status_a = ft_free_status(game->status_a, game->size.y);
		ft_free_stack(&game->map);
		ft_free_txt(&game);
		ft_free_img(&game);
		mlx_terminate(game->mlx);
		free(game);
	}
}

void	ft_free_stack(t_map **stack)
{
	t_map	*tmp;

	if (!stack)
		return ;
	while (*stack)
	{
		tmp = (*stack)->next;
		free((*stack)->map);
		free(*stack);
		*stack = tmp;
	}
	*stack = NULL;
}

void	ft_free_txt(t_init **game)
{
	mlx_delete_texture((*game)->txts.ocean);
	(*game)->txts.ocean = NULL;
	mlx_delete_texture((*game)->txts.wall);
	(*game)->txts.wall = NULL;
	mlx_delete_texture((*game)->txts.collec);
	(*game)->txts.collec = NULL;
	mlx_delete_texture((*game)->txts.exit_c);
	(*game)->txts.exit_c = NULL;
	mlx_delete_texture((*game)->txts.exit_o);
	(*game)->txts.exit_o = NULL;
	mlx_delete_texture((*game)->txts.ship);
	(*game)->txts.ship = NULL;
	mlx_delete_texture((*game)->txts.ship_u);
	(*game)->txts.ship_u = NULL;
	mlx_delete_texture((*game)->txts.ship_d);
	(*game)->txts.ship_d = NULL;
	mlx_delete_texture((*game)->txts.ship_l);
	(*game)->txts.ship_l = NULL;
	mlx_delete_texture((*game)->txts.ship_r);
	(*game)->txts.ship_r = NULL;
	mlx_delete_texture((*game)->txts.shark);
	(*game)->txts.shark = NULL;
}

void	ft_free_img(t_init **game)
{
	mlx_delete_image((*game)->mlx, (*game)->imgs.ocean);
	(*game)->imgs.ocean = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.wall);
	(*game)->imgs.wall = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.collec);
	(*game)->imgs.collec = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.exit_c);
	(*game)->imgs.exit_c = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.exit_o);
	(*game)->imgs.exit_o = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.ship);
	(*game)->imgs.ship = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.ship_u);
	(*game)->imgs.ship_u = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.ship_d);
	(*game)->imgs.ship_d = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.ship_l);
	(*game)->imgs.ship_l = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.ship_r);
	(*game)->imgs.ship_r = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.shark);
	(*game)->imgs.shark = NULL;
}

char	**ft_free_status(char **status, int len)
{
	int	i;

	i = 0;
	while (i <= len)
	{
		free(status[i]);
		status[i] = NULL;
		i++;
	}
	return (status);
}

// char	**free_matrix(char **matrix, int cont)
// {
// 	int	i;

// 	i = 0;
// 	while (i < cont)
// 	{
// 		free(matrix[i]);
// 		matrix[i] = NULL;
// 		i++;
// 	}
// 	free(matrix);
// 	matrix = NULL;
// 	return (matrix);
// }


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_initialize.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-07 12:19:59 by sternero          #+#    #+#             */
/*   Updated: 2024-08-07 12:19:59 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

t_init	*ft_initialize_game(t_init *init)
{
	init->mlx = NULL;
	init->path = NULL;
	init->map = NULL;
	init->status_a = NULL;
	init->status_b = 0;
	init->ship.x = 0;
	init->ship.y = 0;
	init->size.x = 0;
	init->size.y = 0;
	init->moves = 0;
	init->c = 0;
	init->counter = 0;
	init->collec = 0;
	init->flag = 0;
	return (init);
}

int	ft_start_map(char *path)
{
	t_init	*game;

	game = ft_calloc(sizeof(t_init), 1);
	if (!game)
		return (FAILURE);
	game = ft_initialize_game(game); // !!!! 
	game->path = path;
	if (ft_map(&game) == 1)
		return (FAILURE);
	game = ft_find_ship(game); // searchs for player
	game = ft_flood(game); //checks the map
	game->status_b = ft_free_status(game->status_b, game->size.y); // ???
	if (ft_check_failed(game, ft_count_obj(game->map)) == FAILURE) //???
	{
		ft_free_all(game, 1);
		return (FAILURE);
	}
	ft_mlx_init(game); // ???
	ft_free_all(game, 0); 
	return (SUCCESS);
}

t_map	*ft_map_init(t_init *game)
{
	char	*line;
	int		fd;

	fd = open(game->path, O_RDONLY);
	if (fd < 0)
	{
		ft_map_error(ERR_MAP);
		return (NULL);
	}
	line = get_next_line(fd);
	while (line != NULL)
	{
		ft_check_empty_line(game, line);
		line = get_next_line(fd);
	}
	close(fd);
	return (game->map);
}

void	ft_init_txts(t_init *game)
{
	game->txts.wall = mlx_load_png("./imgs/wall.png");
	game->txts.ocean = mlx_load_png("./imgs/ocean.png");
	game->txts.ship = mlx_load_png("./imgs/ship.png");
	game->txts.ship_u = mlx_load_png("./imgs/ship_U.png");
	game->txts.ship_d = mlx_load_png("./imgs/ship_D.png");
	game->txts.ship_l = mlx_load_png("./imgs/ship_L.png");
	game->txts.ship_r = mlx_load_png("./imgs/ship_R.png");
	game->txts.shark = mlx_load_png("./imgs/shark.png");
	game->txts.collec = mlx_load_png("./imgs/collec.png");
	game->txts.exit_c = mlx_load_png("./imgs/exit_c.png");
	game->txts.exit_o = mlx_load_png("./imgs/exit_o.png");
	if (!game->txts.wall || !game->txts.ocean || !game->txts.ship
		|| !game->txts.ship_u || !game->txts.ship_d
		|| !game->txts.ship_l || !game->txts.ship_r
		|| !game->txts.shark || !game->txts.collec
		|| !game->txts.exit_c || !game->txts.exit_o)
	{
		ft_map_error("The textures could not be loaded..\n");
		ft_free_all(game, 1);
		exit(FAILURE);
	}
}

void	ft_init_imgs(t_init *game)
{
	game->imgs.wall = mlx_texture_to_image(game->mlx, game->txts.wall);
	game->imgs.ocean = mlx_texture_to_image(game->mlx, game->txts.ocean);
	game->imgs.ship = mlx_texture_to_image(game->mlx, game->txts.ship);
	game->imgs.ship_d = mlx_texture_to_image(game->mlx, game->txts.ship_d);
	game->imgs.ship_l = mlx_texture_to_image(game->mlx, game->txts.ship_l);
	game->imgs.ship_r = mlx_texture_to_image(game->mlx, game->txts.ship_r);
	game->imgs.ship_u = mlx_texture_to_image(game->mlx, game->txts.ship_u);
	game->imgs.shark = mlx_texture_to_image(game->mlx, game->txts.shark);
	game->imgs.collec = mlx_texture_to_image(game->mlx, game->txts.collec);
	game->imgs.exit_c = mlx_texture_to_image(game->mlx, game->txts.exit_c);
	game->imgs.exit_o = mlx_texture_to_image(game->mlx, game->txts.exit_o);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_materials.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-08 08:17:28 by sternero          #+#    #+#             */
/*   Updated: 2024-08-08 08:17:28 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

t_init	*t_init *ship)
{
	int		i;
	int		j;

	j = 1;
	ship->ship.x = 0;
	ship->ship.y = 0;
	while (j < ship->size.y)
	{
		i = 1;
		while (ship->status_a[j][i] != '\n')
		{
			if (ship->status_a[j][i] == PLAYER)
			{
				ship->ship.x = i;
				ship->ship.y = j;
				return (ship);
			}
			i++;
		}
		j++;
	}
	return (ship);
}

void	ft_objs_init(t_cell *obj)
{
	obj->ship = 0;
	obj->collec = 0;
	obj->exit = 0;
}

t_cell	ft_count_obj(t_map *map)
{
	t_cell	obj;
	int		i;

	ft_objs_init(&obj);
	while (map)
	{
		i = 0;
		while (map->map[i])
		{
			if (map->map[i] == PLAYER)
				obj.ship++;
			if (map->map[i] == COLLECT)
				obj.collec++;
			if (map->map[i] == EXIT)
				obj.exit++;
			i++;
		}
		map = map->next;
	}
	return (obj);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_mlx_init.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-11 07:57:02 by sternero          #+#    #+#             */
/*   Updated: 2024-08-11 07:57:02 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

void	ft_mlx_init(t_init *gm)
{
	gm = ft_find_ship(gm);
	gm->mlx = mlx_init(gm->size.x * 64, gm->size.y * 64, "so_long", true);
	if (!gm || !gm->mlx)
	{
		ft_map_error(ERR_MLX);
		ft_free_all(gm, 1);
		exit(FAILURE);
	}
	ft_init_txts(gm);
	ft_init_imgs(gm);
	ft_drawing_map(gm);
	gm->imgs.ship = NULL;
	mlx_key_hook(gm->mlx, ft_key_press, gm);
	mlx_loop(gm->mlx);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_moves.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-08 09:15:22 by sternero          #+#    #+#             */
/*   Updated: 2024-08-08 09:15:22 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

void	ft_move_ship_right(t_init *game, int y, int x)
{
	t_coord	coord;

	coord.y = y;
	coord.x = x;
	if (game->status_a[y][x + 1] == 'C')
		game->c++;
	else if (game->status_a[y][x + 1] == 'E' && game->c == game->collec)
	{
		mlx_close_window(game->mlx);
		return ;
	}
	else if (game->status_a[y][x + 1] == 'E')
		return ;
	game->moves++;
	game->status_a[y][x] = '0';
	game->status_a[y][x + 1] = 'P';
	game->counter++;
	game->course = 'R';
	game->walking = true;
	ft_printf("Total moves: %s%d\n%s", RED, game->moves, RESET);
	ft_drawing_imgs(game, game->status_a[y][x], coord);
	coord.x++;
	game->walking = false;
	ft_drawing_imgs(game, game->status_a[y][x + 1], coord);
}

void	ft_move_ship_left(t_init *game, int y, int x)
{
	t_coord	coord;

	coord.y = y;
	coord.x = x;
	if (game->status_a[y][x - 1] == 'C')
		game->c++;
	else if (game->status_a[y][x - 1] == 'E' && game->c == game->collec)
	{
		mlx_close_window(game->mlx);
		return ;
	}
	else if (game->status_a[y][x - 1] == 'E')
		return ;
	game->moves++;
	game->status_a[y][x] = '0';
	game->status_a[y][x - 1] = 'P';
	game->counter++;
	game->course = 'L';
	game->walking = true;
	ft_printf("Total moves: %s%d\n%s", RED, game->moves, RESET);
	ft_drawing_imgs(game, game->status_a[y][x], coord);
	coord.x--;
	game->walking = false;
	ft_drawing_imgs(game, game->status_a[y][x - 1], coord);
}

void	ft_move_ship_up(t_init *game, int y, int x)
{
	t_coord	coord;

	coord.y = y;
	coord.x = x;
	if (game->status_a[y - 1][x] == 'C')
		game->c++;
	else if (game->status_a[y - 1][x] == 'E' && game->c == game->collec)
	{
		mlx_close_window(game->mlx);
		return ;
	}
	else if (game->status_a[y - 1][x] == 'E')
		return ;
	game->moves++;
	game->status_a[y][x] = '0';
	game->status_a[y - 1][x] = 'P';
	game->counter++;
	game->course = 'U';
	game->walking = true;
	ft_printf("Total moves: %s%d\n%s", RED, game->moves, RESET);
	ft_drawing_imgs(game, game->status_a[y][x], coord);
	coord.y--;
	game->walking = false;
	ft_drawing_imgs(game, game->status_a[y - 1][x], coord);
}

void	ft_move_ship_down(t_init *game, int y, int x)
{
	t_coord	coord;

	coord.y = y;
	coord.x = x;
	if (game->status_a[y + 1][x] == 'C')
		game->c++;
	else if (game->status_a[y + 1][x] == 'E' && game->c == game->collec)
	{
		mlx_close_window(game->mlx);
		return ;
	}
	else if (game->status_a[y + 1][x] == 'E')
		return ;
	game->moves++;
	game->status_a[y][x] = '0';
	game->status_a[y + 1][x] = 'P';
	game->counter++;
	game->course = 'D';
	game->walking = true;
	ft_printf("Total moves: %s%d\n%s", RED, game->moves, RESET);
	ft_drawing_imgs(game, game->status_a[y][x], coord);
	coord.y++;
	game->walking = false;
	ft_drawing_imgs(game, game->status_a[y + 1][x], coord);
}



/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tools.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-07-30 20:19:21 by sternero          #+#    #+#             */
/*   Updated: 2024-07-30 20:19:21 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

void	ft_map_error(char *str)
{
	ft_printf("\n%s", SLOW_BLINK);
	ft_printf("%s╔═╗ ╦═╗ ╦═╗ ╔═╗ ╦═╗\n", RED);
	ft_printf("%s║╣  ╠╦╝ ╠╦╝ ║ ║ ╠╦╝\n", RED);
	ft_printf("%s╚═╝ ╩╚═ ╩╚═ ╚═╝ ╩╚═%s\n", RED, RESET);
	ft_printf("%s\n", RESET);
	ft_printf("%s\n", str);
	exit(FAILURE);
}

int	ft_map_x(t_map *width)
{
	int	x;

	x = 0;
	while (width->map[x] != '\n')
		x++;
	return (x);
}

int	ft_map_y(t_map *height)
{
	int	y;

	y = 0;
	while (height)
	{
		y++;
		height = height->next;
	}
	return (y);
}

void	ft_game_over_(void)
{
	ft_printf("\n%s", SLOW_BLINK);
	ft_printf("%s╔═╗╔═╗╔╦╗╔═╗  ╔═╗╦  ╦╔═╗╦═╗\n", DARK_BLUE);
	ft_printf("%s║ ╦╠═╣║║║║╣   ║ ║╚╗╔╝║╣ ╠╦╝\n", DARK_YELLOW);
	ft_printf("%s╚═╝╩ ╩╩ ╩╚═╝  ╚═╝ ╚╝ ╚═╝╩╚═\n", DARK_BLUE);
	ft_printf("%s\n", RESET);
}



/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   so_long.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-07-14 09:34:29 by sternero          #+#    #+#             */
/*   Updated: 2024-07-14 09:34:29 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

char	**ft_status_map(t_init *game)
{
	t_map	*tmp;
	char	**status;
	int		i;

	i = 0;
	tmp = game->map;
	status = malloc(sizeof(char *) * (game->size.y + 1));
	if (!status)
		return (NULL);
	while (game->map)
	{
		status[i] = ft_strdup(game->map->map);
		if (!status[i])
		{
			ft_free_status(status, i);
			return (NULL);
		}
		i++;
		game->map = game->map->next;
	}
	game->map = tmp;
	status[i] = NULL;
	return (status);
}

void	ft_key_press(struct mlx_key_image key_image, void *date)
{
	t_init	*game;

	game = date;
	game = ft_find_ship(game);
	if (key_image.key == MLX_KEY_UP && ft_key_check(game) == 1)
		ft_move_ship_up(game, game->ship.y, game->ship.x);
	if (key_image.key == MLX_KEY_DOWN && ft_key_check(game) == 2)
		ft_move_ship_down(game, game->ship.y, game->ship.x);
	if (key_image.key == MLX_KEY_LEFT && ft_key_check(game) == 3)
		ft_move_ship_left(game, game->ship.y, game->ship.x);
	if (key_image.key == MLX_KEY_RIGHT && ft_key_check(game) == 4)
		ft_move_ship_right(game, game->ship.y, game->ship.x);
	if (key_image.key == MLX_KEY_ESCAPE && ft_key_check(game) == 5)
	{
		mlx_close_window(game->mlx);
		return ;
	}
}

int	ft_map(t_init **game)
{
	t_init	*tmp;

	tmp = *game;
	tmp->map = ft_map_init(tmp);
	if (!tmp->map)
	{
		free(tmp);
		return (1);
	}
	tmp->size.x = ft_map_x(tmp->map);
	tmp->size.y = ft_map_y(tmp->map);
	tmp->status_a = ft_status_map(tmp);
	if (!tmp->status_a)
	{
		ft_free_all(tmp, 2);
		return (FAILURE);
	}
	tmp->status_b = ft_status_map(tmp);
	if (!tmp->status_b)
	{
		ft_free_all(tmp, 1);
		return (FAILURE);
	}
	*game = tmp;
	return (SUCCESS);
}

int	main(int argc, char **argv)
{
	int	i;

	i = 0;
	system("clear");
	if (argc != 2)
	{
		ft_map_error(ERR_INIT);
		return (1);
	}
	if (argc == 2)
	{
		if (ft_check_ber(argv[1]) == FAILURE)
		{
			ft_map_error(ERR_FILE);
			return (FAILURE);
		}
		i = ft_start_map(argv[1]);
		if (i == 1)
			return (FAILURE);
	}
	ft_game_over_();
	return (SUCCESS);
}


/*  */ 

srcs bonus
----------------

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cells_bonus.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-15 08:47:06 by sternero          #+#    #+#             */
/*   Updated: 2024-08-15 08:47:06 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

t_init	**ft_fill(char **stat, t_coord size, t_coord now, t_init **game)
{
	if (now.y < 0 || now.y >= size.y || now.x < 0 || now.x >= size.x
		|| stat[now.y][now.x] == '1' || stat[now.y][now.x] == 'F')
		return (game);
	if (stat[now.y][now.x] == 'E')
	{
		stat[now.y][now.x] = 'F';
		(*game)->cell.exit++;
		return (game);
	}
	game = ft_check_cell(game, stat[now.y][now.x]);
	stat[now.y][now.x] = 'F';
	game = ft_fill(stat, size, (t_coord){now.x - 1, now.y}, game);
	game = ft_fill(stat, size, (t_coord){now.x + 1, now.y}, game);
	game = ft_fill(stat, size, (t_coord){now.x, now.y - 1}, game);
	game = ft_fill(stat, size, (t_coord){now.x, now.y + 1}, game);
	return (game);
}

t_init	*ft_flood(t_init *game)
{
	game->cell.ship = 0;
	game->cell.collec = 0;
	game->cell.exit = 0;
	game = *ft_fill(game->status_b, game->size, game->ship, &game);
	return (game);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_cells.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-15 08:47:06 by sternero          #+#    #+#             */
/*   Updated: 2024-08-15 08:47:06 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long.h"

t_init	**ft_fill(char **stat, t_coord size, t_coord now, t_init **game)
{
	if (now.y < 0 || now.y >= size.y || now.x < 0 || now.x >= size.x
		|| stat[now.y][now.x] == '1' || stat[now.y][now.x] == 'F')
		return (game);
	if (stat[now.y][now.x] == 'E')
	{
		stat[now.y][now.x] = 'F';
		(*game)->cell.exit++;
		return (game);
	}
	game = ft_check_cell(game, stat[now.y][now.x]);
	stat[now.y][now.x] = 'F';
	game = ft_fill(stat, size, (t_coord){now.x - 1, now.y}, game);
	game = ft_fill(stat, size, (t_coord){now.x + 1, now.y}, game);
	game = ft_fill(stat, size, (t_coord){now.x, now.y - 1}, game);
	game = ft_fill(stat, size, (t_coord){now.x, now.y + 1}, game);
	return (game);
}

t_init	*ft_flood(t_init *game)
{
	game->cell.ship = 0;
	game->cell.collec = 0;
	game->cell.exit = 0;
	game = *ft_fill(game->status_b, game->size, game->ship, &game);
	return (game);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_check_game_bonus.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-15 10:55:21 by sternero          #+#    #+#             */
/*   Updated: 2024-08-15 10:55:21 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

int	ft_check_obj(t_cell checked, t_cell objects)
{
	if (checked.ship != objects.ship)
		return (FAILURE);
	if (checked.collec != objects.collec)
		return (FAILURE);
	if (checked.exit != objects.exit)
		return (FAILURE);
	return (SUCCESS);
}

int	ft_check_obj_nbr(t_cell objects)
{
	if (objects.ship != 1)
		ft_map_error(ERR_PLAYER);
	if (objects.collec < 1)
		ft_map_error(ERR_COLLEC);
	if (objects.exit != 1)
		ft_map_error(ERR_EXIT);
	return (SUCCESS);
}

int	ft_check_form(t_init *game)
{
	int	i;
	int	j;
	int	l_size;

	j = 0;
	l_size = 0;
	while (game->status_a[j][l_size] != '\n')
		l_size++;
	while (j < game->size.y)
	{
		i = 0;
		while (game->status_a[j][i] != '\n' && game->status_a[j][i] != '\0')
		{
			if (game->status_a[j][i] != '0' && game->status_a[j][i] != WALL
				&& game->status_a[j][i] != 'P' && game->status_a[j][i] != 'C'
				&& game->status_a[j][i] != 'X' && game->status_a[j][i] != EXIT)
				return (1);
			i++;
		}
		if (l_size != i)
			return (FAILURE);
		j++;
	}
	return (SUCCESS);
}

int	ft_check_borders(t_init *game)
{
	int	i;
	int	j;

	j = 0;
	while (j < game->size.y)
	{
		i = 0;
		while (game->status_a[j][i] != '\n' && game->status_a[j][i] != '\0')
		{
			if (j == 0 && game->status_a[j][i] != WALL)
				return (FAILURE);
			if (j == game->size.y - 1 && game->status_a[j][i] != WALL)
				return (FAILURE);
			if (j != 0 && (i == 0 || i == game->size.x - 1)
				&& game->status_a[j][i] != WALL)
				return (FAILURE);
			if (j != game->size.y - 1 && (i == 0 || i == game->size.x - 1)
				&& game->status_a[j][i] != WALL)
				return (FAILURE);
			i++;
		}
		j++;
	}
	return (SUCCESS);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_check_tools_bonus.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-07 11:48:54 by sternero          #+#    #+#             */
/*   Updated: 2024-08-07 11:48:54 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

int	ft_check_failed(t_init *game, t_cell objects)
{
	int	x;

	x = SUCCESS;
	if (ft_check_obj_nbr(objects) == FAILURE)
		x = FAILURE;
	if (ft_check_obj(game->cell, objects) == FAILURE)
		x = FAILURE;
	if (ft_check_form(game) == FAILURE)
		x = FAILURE;
	if (ft_check_borders(game) == FAILURE)
		x = FAILURE;
	if (x == FAILURE)
	{
		(ft_map_error(ERR_GENERAL));
		return (FAILURE);
	}
	return (SUCCESS);
}

int	ft_check_ber(char *file)
{
	size_t	len;

	len = ft_strlen(file);
	if ((file[len - 4] != '.' || file[len - 3] != 'b'
			|| file[len -2] != 'e' || file[len -1] != 'r'))
		return (FAILURE);
	return (SUCCESS);
}

void	ft_check_empty_line(t_init *game, char *line)
{
	t_map	*new;

	if (line[0] == '\n')
	{
		ft_map_error(ERR_LINE);
		free(line);
		exit(FAILURE);
	}
	new = ft_add_line(line);
	ft_last_line(game, new);
	free(line);
}

t_init	**ft_check_cell(t_init	**game, char check)
{
	if (check == 'C')
	{
		(*game)->cell.collec++;
		(*game)->collec++;
	}
	if (check == 'P')
		(*game)->cell.ship++;
	if (check == 'E')
		(*game)->cell.exit++;
	return (game);
}

int	ft_key_check(t_init *game)
{
	if (game->status_a[game->ship.y - 1][game->ship.x] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_UP))
		return (1);
	if (game->status_a[game->ship.y + 1][game->ship.x] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_DOWN))
		return (2);
	if (game->status_a[game->ship.y][game->ship.x - 1] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_LEFT))
		return (3);
	if (game->status_a[game->ship.y][game->ship.x + 1] != '1'
		&& mlx_is_key_down(game->mlx, MLX_KEY_RIGHT))
		return (4);
	if (mlx_is_key_down(game->mlx, MLX_KEY_ESCAPE))
		return (5);
	return (0);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_drawing_moves_bonus.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-16 13:27:50 by sternero          #+#    #+#             */
/*   Updated: 2024-08-16 13:27:50 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

void	ft_ship_go_up(t_init *game, t_coord p, int step)
{
	mlx_delete_image(game->mlx, game->imgs.ship);
	if (step % 2 == 0 && game->imgs.ship_u != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_u,
			p.x * 64, p.y * 64);
	else if (game->imgs.ship_u != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_u,
			p.x * 64, p.y * 64);
}

void	ft_ship_go_down(t_init *game, t_coord p, int step)
{
	mlx_delete_image(game->mlx, game->imgs.ship);
	if (step % 2 == 0 && game->imgs.ship_d != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_d,
			p.x * 64, p.y * 64);
	else if (game->imgs.ship_d != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_d,
			p.x * 64, p.y * 64);
}

void	ft_ship_go_right(t_init *game, t_coord p, int step)
{
	mlx_delete_image(game->mlx, game->imgs.ship);
	if (step % 2 == 0 && game->imgs.ship_r != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_r,
			p.x * 64, p.y * 64);
	else if (game->imgs.ship_r != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_r,
			p.x * 64, p.y * 64);
}

void	ft_ship_go_left(t_init *game, t_coord p, int step)
{
	mlx_delete_image(game->mlx, game->imgs.ship);
	if (step % 2 == 0 && game->imgs.ship_l != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_l,
			p.x * 64, p.y * 64);
	else if (game->imgs.ship_l != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ship_l,
			p.x * 64, p.y * 64);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_drawing_tools_bonus.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-07 08:05:56 by sternero          #+#    #+#             */
/*   Updated: 2024-08-07 08:05:56 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

t_map	*ft_add_line(char *line)
{
	t_map	*new;

	new = malloc(sizeof(t_map));
	if (!new)
		return (NULL);
	new->map = ft_strdup(line);
	if (!new->map)
	{
		free(new);
		return (NULL);
	}
	new->next = NULL;
	return (new);
}

void	ft_last_line(t_init *game, t_map *new)
{
	t_map	*last;

	last = game->map;
	if (!last)
		game->map = new;
	else
	{
		while (last->next)
			last = last->next;
		last->next = new;
	}
}

void	ft_drawing_map(t_init *game)
{
	t_coord	coord;
	int		j;
	int		i;

	j = 0;
	while (j < game->size.y)
	{
		i = 0;
		while (game->status_a[j][i] != '\n' && game->status_a[j][i] != '\0')
		{
			coord.x = i;
			coord.y = j;
			ft_drawing_imgs(game, game->status_a[j][i], coord);
			i++;
		}
		j++;
	}
	ft_drawing_ship(game, game->ship);
}

void	ft_drawing_imgs(t_init *game, char img, t_coord p)
{
	if (img == '1' && game->imgs.wall != NULL)
		mlx_image_to_window(game->mlx, game->imgs.wall, p.x * 64, p.y * 64);
	if (img != '1' && game->imgs.ocean != NULL)
		mlx_image_to_window(game->mlx, game->imgs.ocean, p.x * 64, p.y * 64);
	if (img == 'P')
	{
		ft_drawing_ship(game, p);
		return ;
	}
	if (img == 'C' && game->imgs.collec != NULL)
		mlx_image_to_window(game->mlx, game->imgs.collec, p.x * 64, p.y * 64);
	if (img == 'X' && game->imgs.shark != NULL)
		mlx_image_to_window(game->mlx, game->imgs.shark, p.x * 64, p.y * 64);
	if (img == 'E' && game->imgs.exit_c != NULL)
		mlx_image_to_window(game->mlx, game->imgs.exit_c, p.x * 64, p.y * 64);
}

void	ft_drawing_ship(t_init *game, t_coord p)
{
	if (game->course == 'U' && game->counter > 0)
		ft_ship_go_up(game, p, game->counter);
	else if (game->course == 'D' && game->counter > 0)
		ft_ship_go_down(game, p, game->counter);
	else if (game->course == 'R' && game->counter > 0)
		ft_ship_go_right(game, p, game->counter);
	else if (game->course == 'L' && game->counter > 0)
		ft_ship_go_left(game, p, game->counter);
	else
		mlx_image_to_window(game->mlx, game->imgs.ship, p.x * 64, p.y * 64);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_free_tools_bonus.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-14 09:56:18 by sternero          #+#    #+#             */
/*   Updated: 2024-08-14 09:56:18 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

void	ft_free_all(t_init *game, int error)
{
	if (error == 2)
	{
		ft_free_stack(&game->map);
		free(game);
	}
	if (error == 1)
	{
		game->status_a = ft_free_status(game->status_a, game->size.y);
		ft_free_stack(&game->map);
		free(game);
	}
	if (error == 0)
	{
		game->status_a = ft_free_status(game->status_a, game->size.y);
		ft_free_stack(&game->map);
		ft_free_txt(&game);
		ft_free_img(&game);
		mlx_terminate(game->mlx);
		free(game);
	}
}

void	ft_free_stack(t_map **stack)
{
	t_map	*tmp;

	if (!stack)
		return ;
	while (*stack)
	{
		tmp = (*stack)->next;
		free((*stack)->map);
		free(*stack);
		*stack = tmp;
	}
	*stack = NULL;
}

void	ft_free_txt(t_init **game)
{
	mlx_delete_texture((*game)->txts.ocean);
	(*game)->txts.ocean = NULL;
	mlx_delete_texture((*game)->txts.wall);
	(*game)->txts.wall = NULL;
	mlx_delete_texture((*game)->txts.collec);
	(*game)->txts.collec = NULL;
	mlx_delete_texture((*game)->txts.exit_c);
	(*game)->txts.exit_c = NULL;
	mlx_delete_texture((*game)->txts.exit_o);
	(*game)->txts.exit_o = NULL;
	mlx_delete_texture((*game)->txts.ship);
	(*game)->txts.ship = NULL;
	mlx_delete_texture((*game)->txts.ship_u);
	(*game)->txts.ship_u = NULL;
	mlx_delete_texture((*game)->txts.ship_d);
	(*game)->txts.ship_d = NULL;
	mlx_delete_texture((*game)->txts.ship_l);
	(*game)->txts.ship_l = NULL;
	mlx_delete_texture((*game)->txts.ship_r);
	(*game)->txts.ship_r = NULL;
	mlx_delete_texture((*game)->txts.shark);
	(*game)->txts.shark = NULL;
}

void	ft_free_img(t_init **game)
{
	mlx_delete_image((*game)->mlx, (*game)->imgs.ocean);
	(*game)->imgs.ocean = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.wall);
	(*game)->imgs.wall = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.collec);
	(*game)->imgs.collec = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.exit_c);
	(*game)->imgs.exit_c = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.exit_o);
	(*game)->imgs.exit_o = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.ship);
	(*game)->imgs.ship = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.ship_u);
	(*game)->imgs.ship_u = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.ship_d);
	(*game)->imgs.ship_d = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.ship_l);
	(*game)->imgs.ship_l = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.ship_r);
	(*game)->imgs.ship_r = NULL;
	mlx_delete_image((*game)->mlx, (*game)->imgs.shark);
	(*game)->imgs.shark = NULL;
}

char	**ft_free_status(char **status, int len)
{
	int	i;

	i = 0;
	while (i <= len)
	{
		free(status[i]);
		status[i] = NULL;
		i++;
	}
	return (status);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_initialize_bonus.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-07 12:19:59 by sternero          #+#    #+#             */
/*   Updated: 2024-08-07 12:19:59 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

t_init	*ft_initialize_game(t_init *init)
{
	init->mlx = NULL;
	init->path = NULL;
	init->map = NULL;
	init->status_a = NULL;
	init->status_b = 0;
	init->ship.x = 0;
	init->ship.y = 0;
	init->size.x = 0;
	init->size.y = 0;
	init->moves = 0;
	init->c = 0;
	init->counter = 0;
	init->collec = 0;
	init->flag = 0;
	return (init);
}

int	ft_start_map(char *path)
{
	t_init	*game;

	game = ft_calloc(sizeof(t_init), 1);
	if (!game)
		return (FAILURE);
	game = ft_initialize_game(game);
	game->path = path;
	if (ft_map(&game) == 1)
		return (FAILURE);
	game = ft_find_ship(game);
	game = ft_flood(game);
	game->status_b = ft_free_status(game->status_b, game->size.y);
	if (ft_check_failed(game, ft_count_obj(game->map)) == FAILURE)
	{
		ft_free_all(game, 1);
		return (FAILURE);
	}
	ft_mlx_init(game);
	ft_free_all(game, 0);
	return (SUCCESS);
}

t_map	*ft_map_init(t_init *game)
{
	char	*line;
	int		fd;

	fd = open(game->path, O_RDONLY);
	if (fd < 0)
	{
		ft_map_error(ERR_MAP);
		return (NULL);
	}
	line = get_next_line(fd);
	while (line != NULL)
	{
		ft_check_empty_line(game, line);
		line = get_next_line(fd);
	}
	close(fd);
	return (game->map);
}

void	ft_init_txts(t_init *game)
{
	game->txts.wall = mlx_load_png("./imgs/wall.png");
	game->txts.ocean = mlx_load_png("./imgs/ocean.png");
	game->txts.ship = mlx_load_png("./imgs/ship.png");
	game->txts.ship_u = mlx_load_png("./imgs/ship_U.png");
	game->txts.ship_d = mlx_load_png("./imgs/ship_D.png");
	game->txts.ship_l = mlx_load_png("./imgs/ship_L.png");
	game->txts.ship_r = mlx_load_png("./imgs/ship_R.png");
	game->txts.shark = mlx_load_png("./imgs/shark.png");
	game->txts.collec = mlx_load_png("./imgs/collec.png");
	game->txts.exit_c = mlx_load_png("./imgs/exit_c.png");
	game->txts.exit_o = mlx_load_png("./imgs/exit_o.png");
	if (!game->txts.wall || !game->txts.ocean || !game->txts.ship
		|| !game->txts.ship_u || !game->txts.ship_d
		|| !game->txts.ship_l || !game->txts.ship_r
		|| !game->txts.shark || !game->txts.collec
		|| !game->txts.exit_c || !game->txts.exit_o)
	{
		ft_map_error("The textures could not be loaded..\n");
		ft_free_all(game, 1);
		exit(FAILURE);
	}
}

void	ft_init_imgs(t_init *game)
{
	game->imgs.wall = mlx_texture_to_image(game->mlx, game->txts.wall);
	game->imgs.ocean = mlx_texture_to_image(game->mlx, game->txts.ocean);
	game->imgs.ship = mlx_texture_to_image(game->mlx, game->txts.ship);
	game->imgs.ship_d = mlx_texture_to_image(game->mlx, game->txts.ship_d);
	game->imgs.ship_l = mlx_texture_to_image(game->mlx, game->txts.ship_l);
	game->imgs.ship_r = mlx_texture_to_image(game->mlx, game->txts.ship_r);
	game->imgs.ship_u = mlx_texture_to_image(game->mlx, game->txts.ship_u);
	game->imgs.shark = mlx_texture_to_image(game->mlx, game->txts.shark);
	game->imgs.collec = mlx_texture_to_image(game->mlx, game->txts.collec);
	game->imgs.exit_c = mlx_texture_to_image(game->mlx, game->txts.exit_c);
	game->imgs.exit_o = mlx_texture_to_image(game->mlx, game->txts.exit_o);
}


/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_materials_bonus.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-08 08:17:28 by sternero          #+#    #+#             */
/*   Updated: 2024-08-08 08:17:28 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

t_init	*ft_find_ship(t_init *ship)
{
	int		i;
	int		j;

	j = 1;
	ship->ship.x = 0;
	ship->ship.y = 0;
	while (j < ship->size.y)
	{
		i = 1;
		while (ship->status_a[j][i] != '\n')
		{
			if (ship->status_a[j][i] == PLAYER)
			{
				ship->ship.x = i;
				ship->ship.y = j;
				return (ship);
			}
			i++;
		}
		j++;
	}
	return (ship);
}

void	ft_objs_init(t_cell *obj)
{
	obj->ship = 0;
	obj->collec = 0;
	obj->exit = 0;
}

t_cell	ft_count_obj(t_map *map)
{
	t_cell	obj;
	int		i;

	ft_objs_init(&obj);
	while (map)
	{
		i = 0;
		while (map->map[i])
		{
			if (map->map[i] == PLAYER)
				obj.ship++;
			if (map->map[i] == COLLECT)
				obj.collec++;
			if (map->map[i] == EXIT)
				obj.exit++;
			i++;
		}
		map = map->next;
	}
	return (obj);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_mlx_init_bonus.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-11 07:57:02 by sternero          #+#    #+#             */
/*   Updated: 2024-08-11 07:57:02 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

void	ft_mlx_init(t_init *gm)
{
	gm = ft_find_ship(gm);
	gm->mlx = mlx_init(gm->size.x * 64, gm->size.y * 64, "so_long_bonus", true);
	if (!gm || !gm->mlx)
	{
		ft_map_error(ERR_MLX);
		ft_free_all(gm, 1);
		exit(FAILURE);
	}
	ft_init_txts(gm);
	ft_init_imgs(gm);
	ft_drawing_map(gm);
	gm->imgs.ship = NULL;
	mlx_key_hook(gm->mlx, ft_key_press, gm);
	mlx_loop(gm->mlx);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_moves_bonus.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-08-08 09:15:22 by sternero          #+#    #+#             */
/*   Updated: 2024-08-08 09:15:22 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

void	ft_moves_win(t_init *game)
{
	char	*counter;

	mlx_image_to_window(game->mlx, game->imgs.wall, 64, 1);
	counter = ft_itoa(game->moves);
	mlx_put_string(game->mlx, "Moves: ", 20, 20);
	mlx_put_string(game->mlx, counter, 85, 20);
}

void	ft_move_ship_right(t_init *game, int y, int x)
{
	t_coord	coord;

	coord.y = y;
	coord.x = x;
	if (game->status_a[y][x + 1] == 'C')
		game->c++;
	else if ((game->status_a[y][x + 1] == 'E' && game->c == game->collec)
		|| game->status_a[y][x + 1] == 'X')
		ft_the_end(game);
	else if (game->status_a[y][x + 1] == 'E')
		return ;
	game->moves++;
	game->status_a[y][x] = '0';
	game->status_a[y][x + 1] = 'P';
	game->counter++;
	game->course = 'R';
	game->walking = true;
	ft_moves_win(game);
	ft_printf("Total moves: %s%d\n%s", RED, game->moves, RESET);
	ft_drawing_imgs(game, game->status_a[y][x], coord);
	coord.x++;
	game->walking = false;
	ft_drawing_imgs(game, game->status_a[y][x + 1], coord);
}

void	ft_move_ship_left(t_init *game, int y, int x)
{
	t_coord	coord;

	coord.y = y;
	coord.x = x;
	if (game->status_a[y][x - 1] == 'C')
		game->c++;
	else if ((game->status_a[y][x - 1] == 'E' && game->c == game->collec)
		|| game->status_a[y][x - 1] == 'X')
		ft_the_end(game);
	else if (game->status_a[y][x - 1] == 'E')
		return ;
	game->moves++;
	game->status_a[y][x] = '0';
	game->status_a[y][x - 1] = 'P';
	game->counter++;
	game->course = 'L';
	game->walking = true;
	ft_moves_win(game);
	ft_printf("Total moves: %s%d\n%s", RED, game->moves, RESET);
	ft_drawing_imgs(game, game->status_a[y][x], coord);
	coord.x--;
	game->walking = false;
	ft_drawing_imgs(game, game->status_a[y][x - 1], coord);
}

void	ft_move_ship_up(t_init *game, int y, int x)
{
	t_coord	coord;

	coord.y = y;
	coord.x = x;
	if (game->status_a[y - 1][x] == 'C')
		game->c++;
	else if ((game->status_a[y - 1][x] == 'E' && game->c == game->collec)
		|| game->status_a[y - 1][x] == 'X')
		ft_the_end(game);
	else if (game->status_a[y - 1][x] == 'E')
		return ;
	game->moves++;
	game->status_a[y][x] = '0';
	game->status_a[y - 1][x] = 'P';
	game->counter++;
	game->course = 'U';
	game->walking = true;
	ft_moves_win(game);
	ft_printf("Total moves: %s%d\n%s", RED, game->moves, RESET);
	ft_drawing_imgs(game, game->status_a[y][x], coord);
	coord.y--;
	game->walking = false;
	ft_drawing_imgs(game, game->status_a[y - 1][x], coord);
}

void	ft_move_ship_down(t_init *game, int y, int x)
{
	t_coord	coord;

	coord.y = y;
	coord.x = x;
	if (game->status_a[y + 1][x] == 'C')
		game->c++;
	else if ((game->status_a[y + 1][x] == 'E' && game->c == game->collec)
		|| game->status_a[y + 1][x] == 'X')
		ft_the_end(game);
	else if (game->status_a[y + 1][x] == 'E')
		return ;
	game->moves++;
	game->status_a[y][x] = '0';
	game->status_a[y + 1][x] = 'P';
	game->counter++;
	game->course = 'D';
	game->walking = true;
	ft_moves_win(game);
	ft_printf("Total moves: %s%d\n%s", RED, game->moves, RESET);
	ft_drawing_imgs(game, game->status_a[y][x], coord);
	coord.y++;
	game->walking = false;
	ft_drawing_imgs(game, game->status_a[y + 1][x], coord);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tools_bonus.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-07-30 20:19:21 by sternero          #+#    #+#             */
/*   Updated: 2024-07-30 20:19:21 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

void	ft_map_error(char *str)
{
	ft_printf("\n%s", SLOW_BLINK);
	ft_printf("%s╔═╗ ╦═╗ ╦═╗ ╔═╗ ╦═╗\n", RED);
	ft_printf("%s║╣  ╠╦╝ ╠╦╝ ║ ║ ╠╦╝\n", RED);
	ft_printf("%s╚═╝ ╩╚═ ╩╚═ ╚═╝ ╩╚═%s\n", RED, RESET);
	ft_printf("%s\n", RESET);
	ft_printf("%s\n", str);
	exit(FAILURE);
}

int	ft_map_x(t_map *width)
{
	int	x;

	x = 0;
	while (width->map[x] != '\n')
		x++;
	return (x);
}

int	ft_map_y(t_map *height)
{
	int	y;

	y = 0;
	while (height)
	{
		y++;
		height = height->next;
	}
	return (y);
}

void	ft_the_end(t_init *game)
{
	mlx_close_window(game->mlx);
	return ;
}

void	ft_game_over_(void)
{
	ft_printf("\n%s", SLOW_BLINK);
	ft_printf("%s╔═╗╔═╗╔╦╗╔═╗  ╔═╗╦  ╦╔═╗╦═╗\n", DARK_BLUE);
	ft_printf("%s║ ╦╠═╣║║║║╣   ║ ║╚╗╔╝║╣ ╠╦╝\n", DARK_YELLOW);
	ft_printf("%s╚═╝╩ ╩╩ ╩╚═╝  ╚═╝ ╚╝ ╚═╝╩╚═\n", DARK_BLUE);
	ft_printf("%s\n", RESET);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   so_long_bonus.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sternero <sternero@student.42malaga.com>   #+#  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024-07-14 09:34:29 by sternero          #+#    #+#             */
/*   Updated: 2024-07-14 09:34:29 by sternero         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/so_long_bonus.h"

char	**ft_status_map(t_init *game)
{
	t_map	*tmp;
	char	**status;
	int		i;

	i = 0;
	tmp = game->map;
	status = malloc(sizeof(char *) * (game->size.y + 1));
	if (!status)
		return (NULL);
	while (game->map)
	{
		status[i] = ft_strdup(game->map->map);
		if (!status[i])
		{
			ft_free_status(status, i);
			return (NULL);
		}
		i++;
		game->map = game->map->next;
	}
	game->map = tmp;
	status[i] = NULL;
	return (status);
}

void	ft_key_press(struct mlx_key_image key_image, void *date)
{
	t_init	*game;

	game = date;
	game = ft_find_ship(game);
	if (key_image.key == MLX_KEY_UP && ft_key_check(game) == 1)
		ft_move_ship_up(game, game->ship.y, game->ship.x);
	if (key_image.key == MLX_KEY_DOWN && ft_key_check(game) == 2)
		ft_move_ship_down(game, game->ship.y, game->ship.x);
	if (key_image.key == MLX_KEY_LEFT && ft_key_check(game) == 3)
		ft_move_ship_left(game, game->ship.y, game->ship.x);
	if (key_image.key == MLX_KEY_RIGHT && ft_key_check(game) == 4)
		ft_move_ship_right(game, game->ship.y, game->ship.x);
	if (key_image.key == MLX_KEY_ESCAPE && ft_key_check(game) == 5)
	{
		mlx_close_window(game->mlx);
		return ;
	}
}

int	ft_map(t_init **game)
{
	t_init	*tmp;

	tmp = *game;
	tmp->map = ft_map_init(tmp);
	if (!tmp->map)
	{
		free(tmp);
		return (1);
	}
	tmp->size.x = ft_map_x(tmp->map);
	tmp->size.y = ft_map_y(tmp->map);
	tmp->status_a = ft_status_map(tmp);
	if (!tmp->status_a)
	{
		ft_free_all(tmp, 2);
		return (FAILURE);
	}
	tmp->status_b = ft_status_map(tmp);
	if (!tmp->status_b)
	{
		ft_free_all(tmp, 1);
		return (FAILURE);
	}
	*game = tmp;
	return (SUCCESS);
}

int	main(int argc, char **argv)
{
	int	i;

	i = 0;
	system("clear");
	if (argc != 2)
	{
		ft_map_error(ERR_INIT);
		return (1);
	}
	if (argc == 2)
	{
		if (ft_check_ber(argv[1]) == FAILURE)
		{
			ft_map_error(ERR_FILE);
			return (FAILURE);
		}
		i = ft_start_map(argv[1]);
		if (i == 1)
			return (FAILURE);
	}
	ft_game_over_();
	return (SUCCESS);
}
