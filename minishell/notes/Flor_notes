Minishell
├── OBJECTIVES
│	├──Core Concepts
│	[...]
│	
├──	Understanding key concepts
│	├──	Shell
│	├──	Built-in commands
│	├──	External commands 
│	├──	File Manipulation
│	├──	System Utilities
│	├──	Networking Commands
│	├──	Compilation & Execution
│	├──	Operators and special features
│	└──	Allowed external functions 
│		
├──	ENVIRONMENTAL VARIABLES ( ENVIRON())
│
├──	SIGNALS (signal_handler_notes)
│	├──	Ctrl+D (EOF - End Of File)
│	├──	Ctrl+C (SIGINT).
│	├──	Ctrl+\ (SIGQUIT)
│	├──	Special Case: Child Process & Signals
│	└──	Signals Handling Task Checklist 
│
├── BUILTIN COMMANDS
│	├──	echo
│	├──	
│	├──	
│	└──	
├──	FORKS & Pipes EXPLANATION
│	├──	
├──	LEXER / EXPANDER / PARSER EXPLANATION
================================================================================================
🎯 Objectives
============

🧠 Core Concepts
-------------------
1. Process Management
Use system calls like fork(), execve(), and waitpid() to manage child processes and execute commands.
2. File Descriptors
Work with low-level file I/O, including redirection and piping, using open(), dup2(), and pipe().
3. Signals
Properly handle SIGINT, SIGQUIT, and EOF (Ctrl+C, Ctrl+\ and Ctrl+D).
4. Memory Management
Ensure all dynamically allocated memory is freed — no memory leaks allowed.
5. Read and parse input
Handle command-line inputs, split them into arguments and process quotes and special characters correctly. 
6. Execute commands
Run external programs (like /bin/ls or /bin/cat) and implement built-in commands like cd, echo, export, etc. 
7. Manage environment variables
Store, modify and expand $VARIABLES
8. Implement redirections (<, >, >>)
Redirect input/output correctly.
9. Implement pipes
Allow chaining of commands.
10. Manage process control
Execute commands using fork( ), execve( ), waitpid( ), etc. 
Managing child processes, exit codes, and signals properly.
11. Handling edge cases


🖥️ User Interface
-------------------
Display a working prompt in interactive mode.

Maintain command history (via readline and add_history).

🧩 Parsing
---------------
Read user input and parse commands correctly, including:

Quotes: Single '' and double "" quotes with correct behavior.

Variables: Expand $VARIABLE, handle $? for last exit status.

Tokenization: Split command line into tokens, manage syntax rules.

⚙️ Execution
--------------
Search and execute external commands using execve(), with proper path resolution (via PATH).

Handle absolute and relative paths.

Execute built-in commands directly without execve().

🧱 Built-in Commands
--------------------
Implement these builtins with their specific constraints:

        echo [-n]

        cd [path]

        pwd

        export

        unset

        env

        exit

📂 Redirections
--------------------
< : Redirect input.

> : Redirect output (overwrite).

>> : Redirect output (append).

<< : Here-document, read input until a defined delimiter.

🧵 Pipes
--------------------
Implement | to allow command chaining, where the output of one command becomes the input of the next.

📡 Signals
--------------------
In interactive mode:

        Ctrl+C (SIGINT): Print a new prompt.

        Ctrl+D (EOF): Exit the shell.

        Ctrl+\ (SIGQUIT): Do nothing.

Only one global variable (to store signal number) is allowed and must not expose structures or data.

🚫 Constraints
--------------------
Must use only allowed functions 

Must not have any memory leaks, segmentation faults, or undefined behavior.

Must not interpret characters like [\] or [;].


💡 Understanding key concepts 
==================================

📕 Shell
----------

📌 A shell is a command-line interface (CLI) program that allows users to interact with the operating system by entering commands. It acts as an intermediary between the user and the operating system, interpreting the commands the user inputs and passing them to the system for execution. Essentially, it provides a way for users to control the computer`s functions and run programs.

📌 Key features:
1️⃣ Command Interpretation: The shell takes the commands entered by the user, interprets them, and runs the corresponding program or system function.
2️⃣ Job Control: Shells allow users to run processes in the background, foreground, or as part of a pipeline, making multitasking easier. You can suspend a command, run it in the background, or bring it back to the foreground.
3️⃣ Input/Output Redirection: The shell can redirect the standard input, output, and error of commands. For example:
    🔹 Input Redirection: command < file.txt takes input from a file.
    🔹 Output Redirection: command > file.txt sends the output to a file.
    🔹 Append Output: command >> file.txt appends the output to a file.
4️⃣ Pipes: The shell supports pipes, which allow the output of one command to be passed as input to another. For example, command1 | command2 sends the output of command1 to command2.
5️⃣ Environment Variables: Shells support environment variables, which store system-wide or user-specific settings (e.g., PATH, HOME).
6️⃣ Scripting: Shells allow users to write scripts (a series of commands saved in a file) to automate tasks. For example, a shell script can perform backups, manage files, or deploy applications.
7️⃣ Built-in Commands: Most shells provide a set of built-in commands (like cd, echo, exit) that are part of the shell program itself and don`t require external programs.

📌 Interaction with the Operating System
The shell runs commands that interact with the operating system’s kernel. When you type a command, the shell might invoke system calls (like fork(), exec(), open()) to create processes, execute programs, and handle file operations.
The shell often provides feedback to the user, including the results of commands or any error messages.


📗 Built-in commands
----------------------
These commands should be executed inside minishell, without calling execve( ). 
🔸 echo
    Prints arguments to the terminal.
    Supports the -n flag (prevent a newline).
    Example:
    echo Hello World  # Output: Hello World\n
    echo -n Hello     # Output: Hello
🔸	cd
Changes the current working directory.
    Should handle:
        - absolute paths (cd /home/user).
        - relative paths (cd ../folder).
        - no argument (cd  = should go to $HOME).
        - cd - should switch to the previous directory. 
    Example:
        cd /usr/bin
        cd ..
        cd -  # Switch back
🔸 pwd
    Prints the current working directory.
    Example:
        pwd  # Output: /home/user
🔸 export
    Adds or modifies an environment variable. 
    Without arguments, it prints all exported variables. 
    Example:
        export VAR=value
        export PATH="/usr/local/bin:$PATH"
🔸 unset
    Removes an environment variable. 
    Example:
        unset VAR
🔸 env
    Prints all environment variables. 
    Example:
        env
🔸 exit
    Exits the shell.
    Supports an optional exit code (exit 42).
    Example:
        exit 0

External commands 
----------------------
Minishell should search for the binary in $PATH and execute it using execve().
Basic Commands (Available in /bin/)
ls – List files and directories.
cat – Print file contents.
grep – Search for text in a file.
head – Show first few lines of a file.
tail – Show last few lines of a file.
wc – Count words, lines, and bytes in a file.
cp – Copy files.
mv – Move or rename files.
rm – Remove files.
mkdir – Create a new directory.
rmdir – Remove empty directories.

File Manipulation
----------------------
touch – Create an empty file.
chmod – Change file permissions.
chown – Change file ownership.

System Utilities
----------------------
whoami – Display the current user.
uname – Show system information.
hostname – Show the system hostname.
clear – Clear the terminal screen.

Networking Commands
----------------------
ping – Check network connectivity.
curl – Fetch data from a URL.
wget – Download files from the web.

Compilation & Execution
----------------------
gcc – Compile C programs.
make – Run Makefile commands.
./a.out – Execute a compiled program.


Operators and special features
----------------------------------
Minishell should correctly handle:
	- Redirections
	- Input Redirection (<) – Read input from a file instead of stdin.
			- Example: cat < file.txt
	- Output Redirection (>) – Write output to a file (overwrite).
			- Example: ls > output.txt
	- Append Redirection (>>) – Append output to a file.
			- Example: echo "hello" >> output.txt
	- Pipes (|)
			- Connect multiple commands together.
			- Example: ls | grep .c | wc -l
	- Environment Variable Expansion ($VAR)
			- Replace $VAR with its value in commands.(expansion)
			- Example: echo $HOME  # Output: /home/user
	- Signal Handling
		- Ctrl+C – Interrupts the current command but does not exit the shell.
		- Ctrl+D – Exits the shell (EOF).
		- Ctrl+\ – Should be ignored. (it interrupts the "child" process)

Allowed external functions 
---------------------------> ACTUALIZAR 

readline, rl_clear_history, rl_on_new_line,
rl_replace_line, rl_redisplay, add_history,
printf, malloc, free, 
write, access, open, read,

close, fork, wait, waitpid, wait3, wait4, signal,
sigaction, sigemptyset, sigaddset, kill, exit,

getcwd, chdir, stat, lstat, fstat, unlink, execve,
dup, dup2, pipe, opendir, readdir, closedir,

strerror, perror,

isatty, ttyname, ttyslot, ioctl,

getenv, tcsetattr, tcgetattr, tgetent, tgetflag,
tgetnum, tgetstr, tgoto, tputs


Allowed external functions

Readline library functions
readline: reads a line from standard input with editing capabilities.
Syntax: char *readline(const char *prompt);
Example:  char *input = readline(“minishell> “);

rl_clear_history: clears the history of readline inputs.
Syntax: void rl_clear_history(void);
Example: rl_clear_history();

rl_on_new_line: prepares readline for a new line.
Syntax: void rl_on_nw_line(void);
Example: rl_on_new_line();

rl_replace_line: replaces the current input line in readline.
Syntax: void rl_replace_line(const char *text, int clear_undo);
Example: rl_replace_line(“new text”, 0);

rl_replace_line: replaces the current input line in readline.
Syntax: void rl_replace_line(const char *text, int clear_undo);
Example: rl_replace_line(“new text”, 0);

rl_redisplay: redisplays the readline prompt with current input. 
Syntax: void rl_redisplay(void);
Example: rl_redisplay();

add_history: adds a command to readline history. 
Syntax: void add_history(const char *line);
Example: add_history(input);

Standard library functions
printf: Prints formatted output to stdout.
Syntax: printf(const char *format, ...)
Example: printf("Hello %s, you are %d years old.\n", "Alice", 25);

write: Writes data from a buffer to a file descriptor. 
Syntax: ssize_t write(int fd, const void *buf, size_t count);
Example: write(STDOUT_FILENO, "Hello", 5);

malloc: Allocates a block of memory on the heap. 
Syntax: void *malloc(size_t size);
Example: int *arr = malloc(10 * sizeof(int));

free: Frees memory allocated with malloc. 
Syntax: void free(void *ptr);
Example: free(arr);

File handling functions
access: checks file accessibility.
Syntax: int access(const char *pathname, int mode);
Example: if (access("file.txt", F_OK) == 0) { /* File exists */ }

open: opens or creates a file. 
Syntax: int open(const char *pathname, int flags, mode_t mode);
Example: int fd = open("file.txt", O_RDONLY);

read: reads data from a file descriptor. 
Syntax: ssize_t read(int fd, void *buf, size_t count);
Example: read(fd, buffer, 100);

close: closes a file descriptor.
Syntax: int close(int fd);
Example: close(fd);

Process management
fork: creates a new process.
Syntax: pid_t fork(void);
Example: pid_t pid = fork();

wait: waits for a child process to terminate.
Syntax: pid_t wait(int *status);
Example: wait(NULL);

waitpid: waits for a specific child process.
Syntax: pid_t waitpid(pid_t pid, int *status, int options);
Example: waitpid(pid, NULL, 0);

wait3: waits for a child process with resource usage info. 
Syntax: pid_t wait3(int *status, int options, struct rusage *rusage);
Example: wait3(NULL, 0, NULL);

wait4: waits for a child process with more control.
Syntax: pid_t wait4(pid_t pid, int *status, int options, struct rusage *rusage);
Example: wait4(pid, NULL, 0, NULL);

Signal handling
signal: sets a signal handler.
Syntax: void (*signal(int signum, void(handler)(int)))(int);
Example: signal(SIGINT, handler_function);

sigaction: configures signal handling.
Syntax: int signation(int signum, const struct sigaction *act, struct sigaction *oldact);
Example: sigaction(SIGINT, &sa, NULL);

sigemptyset: initializes an empty signal set.
Syntax: int sigemptyset(sigset_t *set);
Example: sigemptyset(&set);

sigaddset: adds a signal to a signal set. 
Syntax: int sigaddset(sigset_t *set, int signum);
Example: sigaddset(&set, SIGINT);

kill: sends a signal to a process.
Syntax: int kill(pid_t pid, int sig);
Example: kill(pid, SIGKILL);

System & directory functions
exit: terminate a process.
Syntax: void exit(int status);
Example: exit(0);

getcwd: gets the current working directory.
Syntax: char *getcwd(char *buf, size_t size);
Example: getcwd(buffer, sizeof(buffer));

chdir: changes the current directory.
Syntax: int chdir(const char *path);
Example: chdir(“/home/user”);

stat: retrieves file information.
Syntax: int stat(const char *pathname, struct stat *buf);
Example: stat(“file.txt”, &st);

lstat: retrieves file information, including symbolic links.
Syntax: int lstat(const char *pathname, struct stat *buf);
Example: lstat(“symlink”, &st);

fstat: retrieves file information from a file descriptor.
Syntax: int fstat(int fd, struct stat *buf);
Example: fstat(fd, &st);

unlink: deletes a file.
Syntax: int unlink(const char *pathname);
Example: unlink(“file.txt”);

Execution & I/O redirection
execve: executes a program.
Syntax: int execve(const char *pathname, char *const argv[], char *const envp[]);
Example: execve(“/bin/ls”, args, env);

dup: duplicates a file descriptor.
Syntax: int dup(int oldfd);
Example: int newfd = dup(fd);

dup2: duplicates a file descriptor to a specific number.
Syntax: int dup2(int oldfd, int newfd);
Example: dup2(fd, STDOUT_FILENO);

pipe: creates a pipe for interprocess communication.
Syntax: int pipe(int pipefd[2]);
Example: pipe(pipefd);

Directory handling
opendir: opens a directory.
Syntax: DIR *opendir(const char *name);
Example: DIR *dir = opendir(“.”);

readdir: reads directory entries.
Syntax: struct dirent *readdir(DIR *dirp);
Example: readdir(dir);

closedir: closes a directory.
Syntax: int closedir(DIR *dirp);
Example: closedir(dir);

Terminal control and capabilities
strerror: returns a string describing an error number.
Syntax: char *strerror(int errnum);
Example: printf(“%s\n”, strerror(errno));

perror: prints an error message.
Syntax: void perror (const char *s);
Example: perror(“Error opening file”);

isatty: checks if a file descriptor is a terminal.
Syntax: int isatty(int fd);
Example: isatty(STDIN_FILENO);

ttyname: returns the name of the terminal.
Syntax: char *ttyname(int fd);
Example: ttyname(STDIN_FILENO);

ioctl: manipulates device parameters.
Syntax: int ioctl(int fd, unsigned long request, …);
Example: ioctl(fd, TDGETS,&termios_p);

getenv: retrieves an environment variable.
Syntax: char *getenv(const char *name);
Example: getenv(“PATH”);

tcsetattr: set the terminal attributes.
Syntax: int tcsetattr(int fd, int optional_actions, const struct termios *termios_p);
Example: tcsetattr(STDIN_FILENO, TCSANOW, &term);

tcgetattr: gets the current terminal attributes.
Syntax: int tcgetattr(int fd, struct termios *termios_p);
Example: struct termios term;

tcgetattr(STDIN_FILENO, &term);
tgetent: loads the terminal entry from the termcap database.
Syntax: int tgetent(char *bp, const char *name);
Example: char buffer[2048];

tgetent(buffer, getenv(“TERM”));
tgetflag: gets a boolean capability from the termcap database.
Syntax: int tgetflag(const char *id);
Example: tgetflag(“bs”);

tgetnum: gets a numeric capability from the termcap database. 
Syntax: int tgetnum(const char *id);
Example: int columns = tgetnum(“co”); //Get number of columns

tgetstr: gets a string capability from the termcap database.
Syntax: char *tgetstr(const char *id, char **area);
Example: char *clear = tgetstr(“cl”, &area); //Get clear screen command

tgoto: generates cursor movement.
Syntax: char *tgoto(const char *cap, int col, int row);
Example: char *move = tgoto(tgetstr(“cl”, NULL), 10, 5);//Move to (10, 5)

tputs: outputs a termcap string with padding.
Syntax: int tputs(const char *str, int affcnt, int(*putc)(int));
Example: tputs(tgetstr(“cl”, NULL), 1, putchar);  //Clear screen 



===================================================================================

*******************
** Forks & Pipes **
*******************

BRIEF EXPLANATION REGADING
===========================

🔁 Forks

🔗 Pipes

⚙️ Builtin handling

📥 Redirection (placeholder for now)


🧠 Foundational Concepts
**************************

🔁 fork()
---------
🔺Creates a child process that is an almost-exact copy of the parent, but after the fork, the parent and child can run independently.
🔺Returns:
	🔹0 in the child
	🔹The child`s pid in the parent
	🔹-1 if it fails

💻 execve()
---------
🔺 A system call in Unix/Linux that replaces the current process with a new program.
It does not create a new process; it only changes the current process's behavior.
🔺 Must be used only in the child, otherwise you kill your shell.

💡Process Image: it`s all the information the operating system uses to manage and execute a process, including code, data, open files, and environment variables.


🔗 Pipes (pipe(fd[2]))
---------------------------
🔺 Allows one process to write to fd[1] and another to read from fd[0]
🔺 Used to link commands like:
		> ls | grep hello → ls writes to pipe → grep reads from it

🔍 How pipes work?
Pipes are used to connect the output of one command to the input of another. 
They enable powerful data processing by chaining multiple commands together. 
🔸 Command output redirection: when we execute a command, it usually sends its output (called standard output or stdout) to the terminal screen. When we use a pipe, this output is redirected as input (standard input or stdin) to another command. 
🔸 Chaining commands: Pipes allow us to connect commands in a sequence, where the output of the first command becomes the input for the next command. 
🔸 Syntax:
		> cmd1 | cmd2 | cmd3
command 1: produces some output.
command 2: processes the output of command 1.
command 3: processes the output of command 2, and so on. 
🔸 File descriptors: under the hood, pipes use file descriptors. 
stdout of command 1 (file descriptor 1) is connected to the stdin of command 2 (file descriptor 0). That is to say, each pipe has two ends, the read end and the write end.
🔸 Process creation: Each command in the pipeline runs a separate process. The shell creates a pipe (temporary buffer in memory) to connect these processes.


💆 Using Minishell to understand this workflow
************************************************

🧱 File: exec_pipes.c

✅ execute_pipeline()
Called when there’s a command like:
		> echo hi | grep h | cat

Steps:
******
1️⃣ Count the number of pipes (You need N - 1 pipes for N commands.)
2️⃣ Create all pipes:

		pipefd[0], pipefd[1], ...
		
So for ls | grep txt | wc -l, we have:
		Pipe 1 → between ls and grep
		Pipe 2 → between grep and wc
		
Each pipe is a pipefd[2]:
		pipes[0][0] = read end of pipe 1
		pipes[0][1] = write end of pipe 1

		pipes[1][0] = read end of pipe 2
		pipes[1][1] = write end of pipe 2

3️⃣ Loop over each command
🔹 Split command into args
🔹 Call fork_pipes()

				[ PARENT SHELL ]
				  |
				  |-- fork() --> [ CHILD 1: ls ]
				  |                stdout → pipes[0][1]
				  |
				  |-- fork() --> [ CHILD 2: grep txt ]
				  |                stdin  ← pipes[0][0]
				  |                stdout → pipes[1][1]
				  |
				  |-- fork() --> [ CHILD 3: wc -l ]
						           stdin  ← pipes[1][0]
						           
						           
[ ls ] --------writes-----> [ grep txt ] --------writes------> [ wc -l ]
           pipe[0] (fd=1)                     pipe[1] (fd=1)
                    ^                                    ^
                    |                                    |
               stdin ← pipe[0] (fd=0)              stdin ← pipe[1] (fd=0)						       
						           

✅ fork_pipes()

		pid = fork();
		if (pid == 0)
		{
			// In child
			// Set up input/output redirection based on i (pipe index)
			dup2(...);
			close_pipes();
			execute_command(args[0], args, env);
			exit(0);
		}
		

Each child:
🔸 Inherits all pipes
🔸 Sets up its own input/output using dup2()
🔸 Calls execute_command() (next part)

🛠️ What each child does (dup2() logic)
	Child 1 (ls)
		dup2(pipe[0][1], STDOUT_FILENO); // write to pipe
		close unused fds

	Child 2 (grep txt)
		dup2(pipe[0][0], STDIN_FILENO);  // read from pipe 1
		dup2(pipe[1][1], STDOUT_FILENO); // write to pipe 2
		close unused fds

	Child 3 (wc -l)
		dup2(pipe[1][0], STDIN_FILENO);  // read from pipe 2
		close unused fds


🔍 What does dup2(old_fd, new_fd) do?
--------------------------------------

int dup2(int old_fd, int new_fd);

It duplicates a file descriptor: makes [new_fd] now refer to the same thing as [old_fd]
If new_fd already exists, it is closed first.
It returns new_fd, or -1 on error

💡 Why it`s useful:
You can redirect input/output like this:

dup2(pipe_read_fd, STDIN_FILENO);  // Make stdin read from a pipe
dup2(pipe_write_fd, STDOUT_FILENO); // Make stdout write to a pipe

📦 When applied to your fork_pipes()
You have a struct t_pipe with:
		pipes->pipefd[i][0] = read end of pipe i
		pipes->pipefd[i][1] = write end of pipe i

You`re in a loop that runs once per command in a pipeline.
Let’s break down the logic:

✅ Case: First command (i == 0)
		dup2(pipes->pipefd[0][1], STDOUT_FILENO);

You`re saying:
“Instead of writing to the terminal (stdout), write into pipe 0.”

So:
		ls | grep → ls writes into the pipe

✅ Case: Last command (i == pipes->pipe_count)

		dup2(pipes->pipefd[i - 1][0], STDIN_FILENO);

You`re saying:
	“Instead of reading from the terminal (stdin), read from pipe i-1.”

So:
		grep txt | wc -l → wc -l reads from the previous pipe

✅ Case: Middle command
		
		dup2(pipes->pipefd[i - 1][0], STDIN_FILENO);
		dup2(pipes->pipefd[i][1], STDOUT_FILENO);

You`re saying:
		“Read from the previous pipe, write to the next pipe.”

So:
		ls | grep txt | wc -l → grep txt connects input/output to two different pipes.

🧼 After dup2(): Close unused fds
Always close all pipes in the child after setting up redirection — otherwise they stay open and block the flow.
That’s why you call "close_pipes(pipes);" right after the dup2() calls.


=================================================================================
						           
/*
** execute_external_command - Forks and runs an external (non-builtin) program.
**
** @param cmd   The command name (e.g., "ls", "grep", or "./script.sh").
** @param args  Argument array including cmd itself (e.g., {"ls", "-la", NULL}).
** @param env   Pointer to the t_env environment linked list.
**
** This function:
** - Resolves the command’s executable path via check_command_path().
** - Converts the linked list `env` into a `char **envp` array for execve().
** - Forks a child process using fork_and_execute().
** - Waits for the child and updates the shell`s exit status.
** - Cleans up all allocated memory.
**
** Only used for non-builtin commands like:
**    ls, grep, cat, pwd, etc.
**
** If `cmd_path` resolution fails or environment conversion fails, an error is printed and the function returns.
*/

1. Path Resolution
cmd_path = check_command_path(cmd);
If the command is /bin/ls, ./myscript, or ls, this function tries to find the full path.
It may return:
- cmd itself (if it`s already a full path)
- A dynamically allocated string (e.g. /bin/ls)
- NULL → if not found (in that case, the function prints an error)


3. Fork and Execute
pid = fork_and_execute(cmd_path, args, envp);
You call a helper that does:
		if (pid == 0) {
			setup_signals_child();
			execve(cmd_path, args, envp);
		}
The child process runs the external program.
The parent continues after the call.


[⭕] que hace la funcion fork() ???????


4. Wait for Child
r
waitpid(pid, &status, 0);
Parent waits for child process to finish.

5. Update Exit Status
handle_exit_status(status, env);
You analyze the status:

WIFEXITED() → store WEXITSTATUS()

WIFSIGNALED() → store 128 + signal number (like Bash)


6. Memory Cleanup


🧱 File: exec_commands.c
✅ execute_command()

if (is_builtin)
	execute_builtin();
else
	execute_external_command();
Builtins like echo → handled specially

All other commands like ls → go to execute_external_command()

✅ execute_external_command()
Resolve path (e.g. /bin/ls)

Convert env list → char **envp

Call fork_and_execute()

✅ fork_and_execute()

pid = fork();
if (pid == 0)
{
	setup_signals_child();     // 🔥 Add this here!
	execve(cmd_path, args, envp);
}


🔧 File: exec_builtins.c
Builtins are split into two categories:

Builtin	Forked?
cd, exit, export, unset	❌ Run in parent
echo, env, pwd	✅ Run in child
So:

execute_builtin() detects and delegates

execute_child_builtin() does the fork() + exit(...)

execute_parent_builtin() runs directly

✅ Each child builtin is wrapped in a fork() and exit()
✅ Parent builtins modify shell state and avoid fork()



✅ Where to Add setup_signals_child()
You should add it:

In fork_and_execute() → ✅ YES

In execute_child_builtin() → ✅ YES

if (pid == 0)
{
	setup_signals_child(); // <- ADD THIS
	...
}
This way, all child processes handle SIGINT and SIGQUIT correctly like Bash.

🔚 TL;DR — Your Shell Execution Flow

main()
  ↓
execute_pipeline()
  ↳ fork_pipes()
      ↳ fork()
          ↳ dup2() pipe ends
          ↳ execute_command()
              ↳ execute_builtin() or execute_external_command()
                  ↳ fork_and_execute() or fork/exec builtin
                  
✅ Action Items for You
Task															Do It?
Add setup_signals_child() in fork_and_execute()					✅
Add setup_signals_child() in execute_child_builtin()			✅
Understand dup2 pipe logic in fork_pipes()						✅ (see i logic)
Understand builtins and their fork rules						✅


===================================================================================

**********************************************************
** 🔗 Lexer → Parser → Expander → Execution pipeline 🔗 **
**********************************************************

 Let`s go through the Lexer → Parser → Expander → Execution pipeline step by step to clarify what`s 
 happening and how it all connects — especially regarding $?.
 
 🧩 Big Picture Overview
 ------------------------

readline() --> lexer() --> expand_tokens() --> parse_tokens() --> execute_commands()
                          ↘ (expand_variable)                      ↘ execute_command()
                          
✂️ 1. Lexer (lexer.c)
======================

The lexer (lexical analyzer) is responsible for tokenizing the raw input into a sequence of tokens. 
Tokens are the basic building blocks for parsing and later execution. 
Essentially, the lexer reads a command line input, breaks it into smaller parts (tokens), and these
tokens are passed on to the parser for further processing.

Goals of the lexer
------------------
+ Identify tokens: Separate the input into tokens like words, operators (|, >, <, etc.), and special symbols 
(like \n or spaces).
+ Handle quotes: Handle cases like 'single-quoted strings', "double-quoted strings", or escaping special characters.
+ Whitespace management: Ignore extra spaces between tokens but respect the separation between different tokens.

Summary: 
-------
What it does:
📍 Breaks the input line into tokens: Words (e.g., echo, hello) / Symbols (e.g., >, <, |)
		/*
		* lexer() = tokenizes an input string. 
		* Initializes a dynamic array for tokens. 
		* Iterates trough the input, extracting tokens. 
		* Returns an *array of token strings*, terminated by NULL. 
		* Returns NULL if malloc fails. 
		*/

		/*
		* handle_token() = processes the new token in the input string. 
		* Skips whitespaces and newlines. 
		* Handles special chars (>, <, |) as individual tokens. 
		* Extracts word tokens using get_token(). 
		* Expands the token array if necessary. 
		* Returns the updated token array. 
		*/

📍 Handles:
---------
Special symbols with handle_special_char()
	/*
 	* handle_special_char() = Creates a token for a special character. 
 	* Allocates memory for a 3-char string (1 or 2 chars + null terminator). 
 	* Stores the input character(s) and returns the token. 
 	* Returns NULL if malloc fails. 
 	*/
Words with get_token()
	/*
	* get_token() = Extracts a word token from the input string. 
	* Skips leading spaces. 
	* Identifies a token by scanning until a space or a spaceial char. 
	* Allocates memory and copies the token into a new string. 
	* Returns the token or NULL if no valid token is found. 
	*/

Dynamic token storage with reallocate_tokens()
	/*
	* reallocate_tokens() = expands the token array if needed. 
	* Doubles the array size when full. 
	* Allocates new memory and copies existing tokens. 
	* Frees the old array and returns the new one. 
	* Returns NULL if malloc fails. 
	*/


	🔑 It`s token-first, quote/expansion-aware logic is left for later.

 # NOTEs: ChatGPT said !!!!!! What lexer doesn’t do: No quote interpretation (" " or ' '). Tal vez Sofi lo agrega luego o en otra seccion

🪄 2. Expander (expander.c + utils_expander.c)
================================================

The expander should process:
📍 Environment Variables ($VAR):
Replace instances of $VAR in the command string with the value of the corresponding environment variable.
For example, $HOME should be replaced with the value of HOME from the environment (/home/user).
📍 Exit Status ($?):
Replace $? with the exit status of the last command executed.
This will allow commands like echo $? to print the last command`s exit status.
📍 Quotes (Single and Double):
Single quotes (''): Content inside single quotes should be preserved literally. Variables should not be expanded inside single quotes.
Double quotes (""): Content inside double quotes should allow expansion of variables like $VAR.

What it does:
------------
🔺 Iterates through each token from the lexer and looks for $, '', and "".
- Inside expand_variable():
- Tracks quote context ('' vs "")

🔺 Handles 
🔸Special Characters:
						$VAR
						$? (exit status)
🔑 Handles the expansion of these special variables = replaces values inline in the string.
	⚡ For $VAR, search the environment for the corresponding value and replace $VAR with that value.
	⚡ For $?, replace it with the last command`s exit status.

🔸 Quotes
	Single quotes: no expansion
	Double quotes: expansion allowed

# NOTES: according to chatgpt: 
#🔸 $? is handled via:
# if (str[1] == '?')
#    return (ft_itoa(last_exit_status));
# ✅ That means $? is working correctly inside "...". */
🔺 Returns the Expanded String with all variables replaced and quotes handled.

🧱 3. Parser (parser.c)
========================

The parser takes tokens from lexer.c and organizes them into a structured format (t_cmd). 
This structure is later used by the expander and executor.

Goals of the Parser
--------------------
📑 Build a command table (t_cmd) to store commands, arguments, pipes, and redirections.
📑 Validate syntax (e.g., detect missing file names after >, <, >>).
#📑 Prepare for expansion by keeping track of tokens that need expansion ($VAR, $?).


What it does:
--------------
🔺 Receives expanded tokens
🔺 Groups tokens into t_cmd structs to store:
🔸 Command & Arguments (args array)
🔸 Input/Output Redirections (input_fd, output_fd)
			< = input redirection 
			> = output redirection (truncate)
			>> = output redirection (append)
🔸 Pipes (is_pipe)

🔺 Links commands into a pipeline (linked list)

/*
 * parse_tokens() = Parse tokens int a linked list of commands.
 * Iterates through tokenized input (lexer.c)
 * Calls parse_cmd() to create a command structure. 
 * Detects pipes and returns a linked list of commands.
 */

 /*
 * Parse_cmd() = parse a single command from tokens.
 * Iterates through tokens until it encounters a pipe. 
 * Handles input and output redirections. 
 * Stores arguments dynamically in the cmd structure. 
 */
/*
* new_cmd() = Create command structure
* handle_new_cmd() = link the new command to the command list. 
* append_to_array() = append a string to an array.
*/

🧱 4. Execution (execute_commands() → execute_command() → etc.)
================================================================
This layer:
-----------

🔺 Receives parsed + expanded commands
🔺 Decides if a command is:
	🔸Builtin (cd, exit, etc.)
	🔸 External (e.g. ls, echo)
🔺 Calls the correct executor path
🔺 Handles exit statuses using handle_exit_status()

✅ Output and return codes are handled here.

-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-




1️⃣2️⃣3️⃣4️⃣5️⃣6️⃣7️⃣8️⃣9️⃣🔟❔❓⛔✅❎‼️🚫❗❌⭕
🔰🔹🔸🔺🔻⇶→⚡📌📚📖📑📕📗📘📙🔶🔷🔴🟠🟢🟣🟡🔵
💭💬🔊📡⚠💡⭐🏁🚩🛟🔑📢🚨🔎🔍🔌🧮🧪🧵🧩🚀
🎉🔥🎯🍝🎓🍴😴😵🤔🫩💀👾👻💆✋🫶🙊🧠🐢🏆
🧱🎮🚪💣⚔️🛠️🔧🖨️💻🗑📥📦🔚🔁🔗⚙️🥊🥇🎧🎤
🕸🧉🧊🔦⏰☎️🔪✂️📍✏️🪄

=============================================================================

Here`s a Mini Test Suite to help verify that your expander, quotes, and exit status handling ($?) are working correctly in your Minishell. 

🧪 BASIC $? TESTS
bash
Copiar
Editar
# Test 1: $? after a successful command
echo hello
echo $?     # Expected: 0

# Test 2: $? after a failed command
false       # (this is a shell builtin that always fails with status 1)
echo $?     # Expected: 1

# Test 3: $? after a command not found
idontexist
echo $?     # Expected: 127

# Test 4: $? after echoing something (should not affect status)
echo $?
echo $?     # Should match the result of the first echo
🧪 VARIABLE EXPANSION TESTS
bash
Copiar
Editar
# Test 5: Expand environment variable
echo $HOME  # Expected: your actual home path

# Test 6: Expand multiple variables
echo "$HOME $USER"  # Expected: both values

# Test 7: Use in the middle of a string
echo "Welcome, $USER!"  # Expected: Welcome, <your-username>!
🧪 QUOTE HANDLING TESTS
bash
Copiar
Editar
# Test 8: Single quotes prevent expansion
echo '$HOME'   # Expected: $HOME

# Test 9: Double quotes allow expansion
echo "$HOME"   # Expected: your home path

# Test 10: Mixed quote case
echo "'$HOME'" # Expected: 'your-home-path'
🧪 PIPE + EXPANSION
bash
Copiar
Editar
# Test 11: $? in a pipeline (should reflect exit status of last command in pipeline)
false | true
echo $?     # Expected: 0

true | false
echo $?     # Expected: 1
🧪 EDGE CASES
bash
Copiar
Editar
# Test 12: $? inside a command with redirect (you can manually check the file)
echo $? > out.txt
cat out.txt    # Should show exit code of echo

# Test 13: $? inside a string
echo "Exit status was $?"   # Expected: "Exit status was <last_exit_code>"
🧪 BONUS: MINISHELL INSIDE MINISHELL
bash
Copiar
Editar
./minishell
echo $?
exit 42
# In the parent shell:
echo $?     # Expected: 42

✅ test_minishell_expansion.sh
--------------------------------
Here’s a bash test script that runs the $?, variable expansion, and quoting tests automatically, logs the output, and highlights mismatches with Bash behavior.

You can call it test_minishell_expansion.sh, and run it with:

bash
Copiar
Editar
bash test_minishell_expansion.sh ./minishell

--------------------

===============================================
PROBLEM WITH TESTER:
Strip all prompt instances

💡 Bonus Tip
Make your prompt a variable in your shell (e.g., #define PROMPT "minishell$ "), and if you detect that the input is coming from a pipe or script, suppress the prompt. For example:


if (isatty(STDIN_FILENO))
	printf(PROMPT);
This makes your minishell behave like Bash when running scripts or automated tests.
===================================================================================

 📑 Bibliography & Usefull links
==============================================

🔹https://www.gnu.org/software/bash/manual/bash.html
🔹https://www.cs.purdue.edu/homes/grr/SystemsProgrammingBook/Book/Chapter5-WritingYourOwnShell.pdf
🔹https://github.com/gleal42/42_Minishell/tree/master
🔹

SIGNALS
🔹https://man7.org/linux/man-pages/man2/signal.2.html
🔹https://man7.org/linux/man-pages/man7/signal.7.html
🔹



--------------------



## ✅ Minishell – Summary of Flor's Work (08/04)

### 🧠 Signals & Process Context Handling
- **Added** a global variable `g_is_parent` (`volatile sig_atomic_t`) to distinguish between **parent** and **child** processes, especially for correct signal handling.
- **Debug printing added** to:
  - `fork_pipes()`
  - `fork_and_execute()`
  - `execute_child_builtin()`
- **Improved signal logic** in:
  - `catch_sigint()` – handles prompt redraw correctly on `Ctrl+C`
  - `handle_exit_status()` – prints `Quit: 3` or newline based on signal
- ✅ Signal behavior now **mimics Bash more closely** and avoids double prompts or improper redraws.

---

### 🐛 Valgrind & Segfault Fixes
- Found segmentation fault & uninitialized values with Valgrind:
  - `"Conditional jump or move depends on uninitialised value(s)"`
- **Identified cause**: `new_cmd()` (in `parser.c`) allocated memory but left some fields uninitialized.
- **Fixes:**
  - Used `ft_memset()` in `new_cmd()` to safely zero the struct.
  - Reassigned:
    - `input_fd = STDIN_FILENO`
    - `output_fd = STDOUT_FILENO`
  - In `parse_tokens()`, added guard to **only add non-null commands** to the list.
- ✅ Memory is now safely initialized. No Valgrind errors after fix.

---

### 🔁 Fork/Pipe Execution Bug
#### **Issue**:
- Pipelines like `echo $PWD | wc -l` caused:
  - Extra child processes
  - Prompt duplication
  - Wrong `wc -l` output (e.g. `4`)
- Debug output showed:
  - `execute_pipeline()` already handled the full pipeline
  - But `execute_command()` was called again on the same list
- **Cause**: double iteration through `cmd_list`

#### **Fix**:
- Patched `execute_commands()`:
  - Changed `while` to `if` (since only one pipeline is supported)
  - Removed the `cmd_list = cmd_list->next` line after `execute_pipeline()`
- ✅ Cleaned up fork behavior — processes now exit cleanly and consistently.

---

### 🧼 Extra Fork & Extra Newlines (e.g., `wc -l` outputting 4)
- **Suspected causes**:
  1. Empty `cmd_list` node with NULL args causing `echo` to run with no arguments
  2. `execute_pipeline()` iterating one too many commands
- **Fixes:**
  - Added debug prints to track each command execution
  - Inserted **guard clause in `execute_pipeline()`**:
    ```c
    if (!cmd->args || !cmd->args[0])
    {
        cmd = cmd->next;
        continue;
    }
    ```
- ✅ Prevents forking for ghost commands and stops accidental blank output.

---

### 🧨 Critical Bug: Double Fork in Builtins
#### **Cause**:
- `fork_pipes()` already forked once per command
- Inside that child, `execute_command()` → `execute_builtin()` → `execute_child_builtin()` — which **forked again**
- ❌ Resulted in:
  - Double-forked processes
  - Unnecessary children
  - Extra `\n` in output
  - Confusing behavior

#### **Fixes**:
1. `execute_child_builtin()`:
   - Removed `fork()` and `waitpid()`
   - Changed return type to `int`
   - Returns builtin status instead of calling `exit()` itself
2. `execute_builtin()`:
   - Now handles exit logic based on `g_is_parent`:
     ```c
     if (IS_CHILD)
         exit(status);
     else
         env->exit_status = status;
     ```

- ✅ Now only **one fork per command**.
- ✅ `exit()` is only called inside actual forked children.

---

### ✅ Final Result: Stable & Bash-like Behavior

```bash
minishell$ echo $USER | wc -l
[DEBUG] Forking cmd: echo
[DEBUG] Forking cmd: wc
[FORK] In child (pid = 723261)
[FORK] In parent, waiting
[FORK] In child (pid = 723262)
[FORK] In parent, waiting
[DEBUG] Executing cmd: wc
[FORK] In child (pid = 723263)
[FORK] In parent, waiting
1
[EXIT STATUS] signal = 0, status = 0
```

- ✅ Only correct number of forks
- ✅ No extra lines
- ✅ Correct output & exit status
- ✅ Shell stays open

---

Work done 09/04
-----------------

1) Made a copy of the Excell test cases, applied format and features for organization.
2) Testing syntax group of input.

Test			Expected Status					Fix
Spaces only			0						ft_strtrim() and check if empty
Tabs only			0						Same as above
:					0						Treat as builtin noop
!					1						Handle as unsupported (event not found)
#					0						Treat as comment (ignore)

2.1 ) Create a new file utils_input.c where I added a handler for this special situation. Prototypes have been added in parser.hace
2.2 ) fixing cases with Invalid Redirections ">" or "<" alone (no other chars)

🔍 Should These Be Handled Before the Parser?
No. These cases are syntactically valid enough to be tokenized (e.g., > is a token).
But invalid at parsing time (because a file/token is expected after redirection).
So: ✅ These should be handled in the parser, not before it.

summary of handling:
Case				Handle In	How to fix
------------------------------------------------------------------------------------
>, <, >>, 			parser.c	Check tokens[i + 1] exists before opening
					parser2.c		modified parse_cmd() to include the check for filename or token (and parse_tokens() to pass t_env)
								Created parser2.c to include all functions 42Norm complaint.

>>>, <<<, ><, etc.	lexer.c		Detect invalid token length > 2 and reject with syntax error

<<					nowhere (is for heredoc which has not been implemented just yet)

Explanation: fixing >, <, >>, issues:
-----------------------------------------
$> >
bash: syntax error near unexpected token `newline`
This means: bash expects a file or word after > and found nothing — hence the syntax error.

So, a function to check that was added for each of the cases of redirection.
(when heredoc is added it should be added here too)
This helper function validates the presence of a filename or token after a redirection operator like >, >>, or <.