BRIEF EXPLANATION REGADING
===========================

ğŸ” Forks

ğŸ”— Pipes

âš™ï¸ Builtin handling

ğŸ“¥ Redirection (placeholder for now)


ğŸ§  Foundational Concepts
**************************

ğŸ” fork()
---------
ğŸ”ºCreates a child process that is an almost-exact copy of the parent, but after the fork, the parent and child can run independently.
ğŸ”ºReturns:
	ğŸ”¹0 in the child
	ğŸ”¹The child's pid in the parent
	ğŸ”¹-1 if it fails

ğŸ’» execve()
---------
ğŸ”º A system call in Unix/Linux that replaces the current process with a new program.
It does not create a new process; it only changes the current process's behavior.
ğŸ”º Must be used only in the child, otherwise you kill your shell.

ğŸ’¡Process Image: it's all the information the operating system uses to manage and execute a process, including code, data, open files, and environment variables.


ğŸ”— Pipes (pipe(fd[2]))
---------------------------
ğŸ”º Allows one process to write to fd[1] and another to read from fd[0]
ğŸ”º Used to link commands like:
		> ls | grep hello â†’ ls writes to pipe â†’ grep reads from it

ğŸ” How pipes work?
Pipes are used to connect the output of one command to the input of another. 
They enable powerful data processing by chaining multiple commands together. 
ğŸ”¸ Command output redirection: when we execute a command, it usually sends its output (called standard output or stdout) to the terminal screen. When we use a pipe, this output is redirected as input (standard input or stdin) to another command. 
ğŸ”¸ Chaining commands: Pipes allow us to connect commands in a sequence, where the output of the first command becomes the input for the next command. 
ğŸ”¸ Syntax:
		> cmd1 | cmd2 | cmd3
command 1: produces some output.
command 2: processes the output of command 1.
command 3: processes the output of command 2, and so on. 
ğŸ”¸ File descriptors: under the hood, pipes use file descriptors. 
stdout of command 1 (file descriptor 1) is connected to the stdin of command 2 (file descriptor 0). That is to say, each pipe has two ends, the read end and the write end.
ğŸ”¸ Process creation: Each command in the pipeline runs a separate process. The shell creates a pipe (temporary buffer in memory) to connect these processes.


ğŸ’† Using Minishell to understand this workflow
************************************************

ğŸ§± File: exec_pipes.c

âœ… execute_pipeline()
Called when thereâ€™s a command like:
		> echo hi | grep h | cat

Steps:
******
1ï¸âƒ£ Count the number of pipes (You need N - 1 pipes for N commands.)
2ï¸âƒ£ Create all pipes:

		pipefd[0], pipefd[1], ...
		
So for ls | grep txt | wc -l, we have:
		Pipe 1 â†’ between ls and grep
		Pipe 2 â†’ between grep and wc
		
Each pipe is a pipefd[2]:
		pipes[0][0] = read end of pipe 1
		pipes[0][1] = write end of pipe 1

		pipes[1][0] = read end of pipe 2
		pipes[1][1] = write end of pipe 2

3ï¸âƒ£ Loop over each command
ğŸ”¹ Split command into args
ğŸ”¹ Call fork_pipes()

				[ PARENT SHELL ]
				  |
				  |-- fork() --> [ CHILD 1: ls ]
				  |                stdout â†’ pipes[0][1]
				  |
				  |-- fork() --> [ CHILD 2: grep txt ]
				  |                stdin  â† pipes[0][0]
				  |                stdout â†’ pipes[1][1]
				  |
				  |-- fork() --> [ CHILD 3: wc -l ]
						           stdin  â† pipes[1][0]
						           
						           
[ ls ] --------writes-----> [ grep txt ] --------writes------> [ wc -l ]
           pipe[0] (fd=1)                     pipe[1] (fd=1)
                    ^                                    ^
                    |                                    |
               stdin â† pipe[0] (fd=0)              stdin â† pipe[1] (fd=0)						       
						           

âœ… fork_pipes()

		pid = fork();
		if (pid == 0)
		{
			// In child
			// Set up input/output redirection based on i (pipe index)
			dup2(...);
			close_pipes();
			execute_command(args[0], args, env);
			exit(0);
		}
		

Each child:
ğŸ”¸ Inherits all pipes
ğŸ”¸ Sets up its own input/output using dup2()
ğŸ”¸ Calls execute_command() (next part)

ğŸ› ï¸ What each child does (dup2() logic)
	Child 1 (ls)
		dup2(pipe[0][1], STDOUT_FILENO); // write to pipe
		close unused fds

	Child 2 (grep txt)
		dup2(pipe[0][0], STDIN_FILENO);  // read from pipe 1
		dup2(pipe[1][1], STDOUT_FILENO); // write to pipe 2
		close unused fds

	Child 3 (wc -l)
		dup2(pipe[1][0], STDIN_FILENO);  // read from pipe 2
		close unused fds


ğŸ” What does dup2(old_fd, new_fd) do?
--------------------------------------

int dup2(int old_fd, int new_fd);

It duplicates a file descriptor: makes [new_fd] now refer to the same thing as [old_fd]
If new_fd already exists, it is closed first.
It returns new_fd, or -1 on error

ğŸ’¡ Why it's useful:
You can redirect input/output like this:

dup2(pipe_read_fd, STDIN_FILENO);  // Make stdin read from a pipe
dup2(pipe_write_fd, STDOUT_FILENO); // Make stdout write to a pipe

ğŸ“¦ When applied to your fork_pipes()
You have a struct t_pipe with:
		pipes->pipefd[i][0] = read end of pipe i
		pipes->pipefd[i][1] = write end of pipe i

You're in a loop that runs once per command in a pipeline.
Letâ€™s break down the logic:

âœ… Case: First command (i == 0)
		dup2(pipes->pipefd[0][1], STDOUT_FILENO);

You're saying:
â€œInstead of writing to the terminal (stdout), write into pipe 0.â€

So:
		ls | grep â†’ ls writes into the pipe

âœ… Case: Last command (i == pipes->pipe_count)

		dup2(pipes->pipefd[i - 1][0], STDIN_FILENO);

You're saying:
	â€œInstead of reading from the terminal (stdin), read from pipe i-1.â€

So:
		grep txt | wc -l â†’ wc -l reads from the previous pipe

âœ… Case: Middle command
		
		dup2(pipes->pipefd[i - 1][0], STDIN_FILENO);
		dup2(pipes->pipefd[i][1], STDOUT_FILENO);

You're saying:
		â€œRead from the previous pipe, write to the next pipe.â€

So:
		ls | grep txt | wc -l â†’ grep txt connects input/output to two different pipes.

ğŸ§¼ After dup2(): Close unused fds
Always close all pipes in the child after setting up redirection â€” otherwise they stay open and block the flow.
Thatâ€™s why you call "close_pipes(pipes);" right after the dup2() calls.


=================================================================================
						           
/*
** execute_external_command - Forks and runs an external (non-builtin) program.
**
** @param cmd   The command name (e.g., "ls", "grep", or "./script.sh").
** @param args  Argument array including cmd itself (e.g., {"ls", "-la", NULL}).
** @param env   Pointer to the t_env environment linked list.
**
** This function:
** - Resolves the commandâ€™s executable path via check_command_path().
** - Converts the linked list `env` into a `char **envp` array for execve().
** - Forks a child process using fork_and_execute().
** - Waits for the child and updates the shell's exit status.
** - Cleans up all allocated memory.
**
** Only used for non-builtin commands like:
**    ls, grep, cat, pwd, etc.
**
** If `cmd_path` resolution fails or environment conversion fails, an error is printed and the function returns.
*/

1. Path Resolution
cmd_path = check_command_path(cmd);
If the command is /bin/ls, ./myscript, or ls, this function tries to find the full path.
It may return:
- cmd itself (if it's already a full path)
- A dynamically allocated string (e.g. /bin/ls)
- NULL â†’ if not found (in that case, the function prints an error)


3. Fork and Execute
pid = fork_and_execute(cmd_path, args, envp);
You call a helper that does:
		if (pid == 0) {
			setup_signals_child();
			execve(cmd_path, args, envp);
		}
The child process runs the external program.
The parent continues after the call.


[â­•] que hace la funcion fork() ???????


4. Wait for Child
r
waitpid(pid, &status, 0);
Parent waits for child process to finish.

5. Update Exit Status
handle_exit_status(status, env);
You analyze the status:

WIFEXITED() â†’ store WEXITSTATUS()

WIFSIGNALED() â†’ store 128 + signal number (like Bash)


6. Memory Cleanup


ğŸ“•ğŸ“—ğŸ“˜ğŸ“™â†’ğŸ“¢ğŸš¨ğŸ”ğŸ§±âš ğŸ’¡ğŸ® ğŸ‰ ğŸ”°ğŸğŸš©ğŸ›ŸğŸ”‘ğŸšªğŸ”ŒğŸ§®ğŸš¦âš¡ğŸ’£
ğŸ”¶ğŸ”·ğŸ”´ğŸŸ ğŸŸ¢ğŸŸ£ğŸŸ¡ğŸ”µâ‡¶ğŸ™Š ğŸğŸ§ ğŸ¢ ğŸ› ï¸ğŸ”§ğŸ’­ğŸ’¬ğŸ’€ğŸ”ŠğŸ“¡  ğŸ–¨ï¸ğŸ’»ğŸ“
1ï¸âƒ£2ï¸âƒ£3ï¸âƒ£4ï¸âƒ£5ï¸âƒ£6ï¸âƒ£7ï¸âƒ£8ï¸âƒ£9ï¸âƒ£ğŸ”Ÿ.ğŸš«â—â­ ğŸ˜´ğŸ˜µğŸ´ğŸ¤”âœ‹ğŸ“¦ ğŸ—‘ğŸ“¥ğŸš€ğŸ”¥ğŸ¯ 
âŒâ­• ğŸ”¹ğŸ”¸ğŸ”ºğŸ”»ğŸ“ŒğŸ§ªğŸ§µğŸ§©â”â“â›”âœ…ââ€¼ï¸ğŸ”šğŸ”ğŸ”—âš™ï¸ ğŸ‘¾ğŸ‘»ğŸ’†

ğŸ§± File: exec_commands.c
âœ… execute_command()

if (is_builtin)
	execute_builtin();
else
	execute_external_command();
Builtins like echo â†’ handled specially

All other commands like ls â†’ go to execute_external_command()

âœ… execute_external_command()
Resolve path (e.g. /bin/ls)

Convert env list â†’ char **envp

Call fork_and_execute()

âœ… fork_and_execute()

pid = fork();
if (pid == 0)
{
	setup_signals_child();     // ğŸ”¥ Add this here!
	execve(cmd_path, args, envp);
}


ğŸ”§ File: exec_builtins.c
Builtins are split into two categories:

Builtin	Forked?
cd, exit, export, unset	âŒ Run in parent
echo, env, pwd	âœ… Run in child
So:

execute_builtin() detects and delegates

execute_child_builtin() does the fork() + exit(...)

execute_parent_builtin() runs directly

âœ… Each child builtin is wrapped in a fork() and exit()
âœ… Parent builtins modify shell state and avoid fork()



âœ… Where to Add setup_signals_child()
You should add it:

In fork_and_execute() â†’ âœ… YES

In execute_child_builtin() â†’ âœ… YES

if (pid == 0)
{
	setup_signals_child(); // <- ADD THIS
	...
}
This way, all child processes handle SIGINT and SIGQUIT correctly like Bash.

ğŸ”š TL;DR â€” Your Shell Execution Flow

main()
  â†“
execute_pipeline()
  â†³ fork_pipes()
      â†³ fork()
          â†³ dup2() pipe ends
          â†³ execute_command()
              â†³ execute_builtin() or execute_external_command()
                  â†³ fork_and_execute() or fork/exec builtin
                  
âœ… Action Items for You
Task	Do It?
Add setup_signals_child() in fork_and_execute()	âœ…
Add setup_signals_child() in execute_child_builtin()	âœ…
Understand dup2 pipe logic in fork_pipes()	âœ… (see i logic)
Understand builtins and their fork rules	âœ…

