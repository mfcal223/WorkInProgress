// INCLUDES
// ======================

//structures.h

#ifndef STRUCTURES_H
# define STRUCTURES_H

typedef enum s_state
{
	EATING = 0,						// Philosopher is eating
	SLEEPING = 1,					// Philosopher is sleeping
	THINKING = 2,					// Philosopher is thinking
	DIE = 3,						// Philosopher is dead
	FULL = 4,						// Philosopher is full
	OFF = 5							// Philosopher is idle, is doing nothing
}	t_state;

typedef struct s_philo
{
	int				id;				// Philosopher's id
	int				meals;			// Number of meals eaten
	pthread_mutex_t	*fork_l;		// Left fork
	pthread_mutex_t	*fork_r;		// Right fork
	pthread_mutex_t	mut_last_eat;	// Mutex for the last time the philos ate
	pthread_mutex_t	mut_num_meals;	// Mutex for the number of meals	
	pthread_mutex_t	mut_state;		// Mutex for the state
	struct s_data	*data;			// Pointer to the main data structure
	t_state			state;			// Current state of the philosopher
	uint64_t		last_eat;		// Last time the philosopher ate
}	t_philo;

typedef struct s_data
{
	int				nb_philos;			
	int				num_meal;			
	int				finished;			
	bool			keep_iterating;
	uint64_t		eat_time;
	uint64_t		die_time;				
	uint64_t		sleep_time;
	uint64_t		start_time;
	pthread_mutex_t	mut_eat_t;
	pthread_mutex_t	mut_die_t;				
	pthread_mutex_t	mut_sleep_t;
	pthread_mutex_t	mut_print;
	pthread_mutex_t	mut_nb_philos;
	pthread_mutex_t	mut_keep_iter;
	pthread_mutex_t	mut_start_time;
	pthread_t		monit_all_alive;
	pthread_t		monit_all_full;
	pthread_t		*philo_ths;
	pthread_mutex_t	*forks;
	t_philo			*philos;
}	t_data;

#endif

// philo.h

#ifndef PHILO_H
# define PHILO_H

// ------------------------- External libraries ----------------------------- //

# include <pthread.h>       
/* pthread_create, pthread_join, pthread_mutex_init, pthread_mutex_lock, 
    pthread_mutex_unlock, pthread_mutex_destroy */
# include <stdbool.h>       /* bool, true, false */
# include <stdint.h>        /* uint64_t, uint32_t, uint16_t, uint8_t */
# include <stdio.h>         /* printf, NULL... */ 
# include <stdlib.h>        /* malloc, free, exit */
# include <string.h>        /* strerror */
# include <sys/time.h>  
# include <unistd.h>        /* usleep, write, fork, execve... */

// ------------------------- Own libraries --------------------------------- //

# include "structures.h"                /* Structures */
# include "colors.h"                    /* colors */
# include "functions.h"                 /* Functions */
# include "messages.h"                  /* Messages */

#endif

//messages.h

#ifndef MESSAGES_H
# define MESSAGES_H

// ------- Error Messages ------------------------------------------------------

# define ERROR_ARGS_1 "Error: Wrong number of arguments\n"
# define ERROR_ARGS_2 "Error: Number of philosophers must be at least 2\n"
# define ERROR_ARGS_3 "Error: Time to die must be at least 60 ms\n"
# define ERROR_ARGS_4 "Error: Time to eat must be at least 60 ms\n"
# define ERROR_ARGS_5 "Error: Time to sleep must be at least 60 ms\n"
# define ERROR_ARGS_6 "Error: Number of meals must be at least 1\n"

// ------- Error Codes ---------------------------------------------------------

# define INPUT_ERROR 1
# define MALLOC_ERROR 2

// ------- Messages ------------------------------------------------------------

# define EAT "is eating ü§§"
# define DIED "is died üíÄ"
# define SLEEP "is sleeping üò¥"
# define TAKE_FORKS "has taken a fork üç¥"
# define THINK "is thinking ü§Ø"

// ------- Return Codes --------------------------------------------------------

# define FAILURE 1
# define SUCCESS 0

#endif

//functions.h

#ifndef FUNCTIONS_H
# define FUNCTIONS_H

// ------- ft_check.c ------------------------------------------------------- //

int			ft_check_args(int c, char **v);
int			ft_error_argv(int argc, char **argv);
int			ft_argv_num(int argc, char **argv);
t_state		ft_how_are_you(t_philo *philo);
void		*ft_are_you_dead(void *data);

// ------- ft_controller.c -------------------------------------------------- //

bool		ft_keep_or_not(t_data *data);
bool		ft_has_eaten(t_data *value, t_philo *philo);
bool		ft_rip(t_philo *philo);
bool		ft_num_meals(t_data *value);

// ------- ft_eat_n_think.c ------------------------------------------------- //

int			ft_times_eating(t_philo *philo);
int			ft_eating(t_philo *philo);
int			ft_thinking(t_philo *philo);

// ------- ft_forks.c ------------------------------------------------------- //

void		ft_drop_fork(t_philo *philo);
void		ft_drop_fork_l(t_philo *philo);
void		ft_drop_fork_r(t_philo *philo);

// ------- ft_free_tools.c ------------------------------------------------- //

void		leaks(void);
void		ft_free_all(t_data *data);
int			ft_malloc(t_data *data);

// ------- ft_gettering_a.c ------------------------------------------------- //

void		ft_get_last_meal(t_philo *philo);
void		ft_get_num_meals(t_philo *philo);
uint64_t	ft_get_die(t_data *data);
uint64_t	ft_get_eat(t_data *data);
uint64_t	ft_get_last_eat(t_philo *philo);

// ------- ft_gettering_b.c ------------------------------------------------- //

int			ft_get_fork_l(t_philo *philo);
int			ft_get_fork_r(t_philo *philo);
int			get_forks(t_philo *philo);

// ------- ft_gettering_c.c ------------------------------------------------- //

uint64_t	ft_get_start(t_data *data);
uint64_t	ft_get_sleep(t_data *data);

// ------- ft_init.c -------------------------------------------------------- //

int			ft_init_values(t_data *data, int argc, char **argv);
int			ft_init_threads(t_data *data);
int			ft_init_philos(int argc, char **argv);
int			ft_init_philos_data(t_data *data);
int			ft_init_forks(t_data *data);

// ------- ft_philo.c ------------------------------------------------------- //

// int		main(int argc, char **argv);
// main function is the entry point of the program. It checks the number of
// arguments and the values of the arguments passed to the program. If the
// arguments are not valid, it calls ft_check_args() with the corresponding
// error number. 

void		*ft_the_core(void *philo);
int			ft_only_one(t_philo *philo);
void		*ft_the_watchdog(void *value);
int			ft_sincro(t_data *data);

// ------- ft_printing.c ---------------------------------------------------- //

void		ft_writing(t_data *data, int id, char *src);
void		ft_instruction(void);

// ------- ft_sleep.c ------------------------------------------------------- //

int			ft_sleeping(t_philo *philo);
void		ft_sleep_for_eating(t_philo *philo);

// ------- ft_tools_1.c ----------------------------------------------------- //

void		ft_delay(uint64_t pause);
uint64_t	ft_my_watch(void);
int			ft_atoi(char *str);

// ------- ft_tools_2.c ----------------------------------------------------- //

int			ft_num_philos(t_data *data);
void		ft_game_over(t_data *value);
void		ft_keep_flag(t_data *value, bool now);
void		ft_status(t_philo *philo, t_state status);

#endif

//colors.h

#ifndef COLORS_H
# define COLORS_H

// To reset the color of the text to the default color (white):

# define RESET		"\033[0m"    // expample: printf(RESET "Hello World\n");

// To print the texts in diferent colors:

# define RED		"\033[0;31m" // expample: printf(RED "Hello World\n");
# define GREEN		"\033[0;32m" // expample: @echo -e "$(GREEN)Hello World"
# define YELLOW		"\033[0;33m" 
# define BLUE		"\033[0;34m" 
# define MAGENTA	"\033[0;35m" 
# define CYAN		"\033[0;36m" 
# define WHITE		"\033[0;37m"
# define ORANGE 	"\033[1;31m"

// To print the bold texts in diferent colors:

# define BDBLACK 	"\033[1;30m" // expample: printf(BDBLACK "Hello World\n");
# define BDRED 		"\033[1;31m" // expample: @echo -e "$(BDRED)Hello World"
# define BDGREEN 	"\033[1;32m"
# define BDYELLOW 	"\033[1;33m"
# define BDBLUE 	"\033[1;34m"
# define BDMAGENTA 	"\033[1;35m"
# define BDCYAN 	"\033[1;36m"
# define BDWHITE 	"\033[1;37m"

// To print the underlined texts in diferent colors:

# define ULRED 		"\033[4;31m" // expample: printf(ULRED "Hello World\n");
# define ULGREEN 	"\033[4;32m" // expample: @echo -e "$(ULGREEN)Hello World"
# define ULYELLOW 	"\033[4;33m"
# define ULBLUE 	"\033[4;34m"
# define ULMAGENTA 	"\033[4;35m"
# define ULCYAN 	"\033[4;36m"
# define ULWHITE 	"\033[4;37m"

// To print lines, shades, blocks and arrows:

# define EQLIN 		"\u2550" // EQUAL LINE     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# define LSHADE 	"\u2591" // LIGHT SHADE    ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
# define MSHADE 	"\u2592" // MEDIUM SHADE   ‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí‚ñí
# define HSHADE 	"\u2593" // HEAVY SHADE    ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì
# define FBLOCK 	"\u2588" // FULL BLOCK     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
# define EBLOCK 	"\u258d" // EIGHTH BLOCK   ‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç‚ñç
# define ARROWRG 	"\u2911" // RIGHT ARROW    ‚§ë‚§ë‚§ë‚§ë‚§ë‚§ë‚§ë‚§ë‚§ë‚§ë‚§ë‚§ë‚§ë‚§ë

#endif

/*-------------------- FUNCTIONS ----------------------------------*/

//FT_CHECK.C
#include "../includes/philo.h"

int	ft_check_args(int c, char **v)
{
	if (c < 5 || c > 6 || ft_argv_num(c, v) != 0 || ft_error_argv(c, v))
		return (INPUT_ERROR);
	return (SUCCESS);
}

/* The function ft_check_args() checks the arguments: if the number of arguments
   is less than 5 or more than 6, or if the arguments are not numbers, or if the
   arguments are less than 60, it returns an error. Otherwise, it returns a 
   success message. */

int	ft_error_argv(int argc, char **argv)
{
	int	i;

	i = 1;
	if (argc == 6 && ft_atoi(argv[5]) <= 0)
		return (INPUT_ERROR);
	if (ft_atoi(argv[i]) < 1 || ft_atoi(argv[i]) > 200)
		return (INPUT_ERROR);
	while (++i < 5)
	{
		if (ft_atoi(argv[i]) < 60)
			return (INPUT_ERROR);
	}
	return (SUCCESS);
}

/* The function ft_error_argv() checks the arguments: if the number of 
   philosophers is less than 1 or more than 200, or if the time to die, 
   the time to eat, or the time to sleep is less than 60, it returns an 
   error. Otherwise, it returns a success message. */

int	ft_argv_num(int argc, char **argv)
{
	int	i;
	int	j;

	i = 1;
	while (i < argc)
	{
		j = 0;
		while (argv[i][j] != '\0')
		{
			if (argv[i][j] < '0' || argv[i][j] > '9')
			{
				return (INPUT_ERROR);
			}
			j++;
		}
		i++;
	}
	return (SUCCESS);
}

/* The function ft_argv_num() checks the arguments: if the arguments are not 
   numbers, it returns an error. Otherwise, it returns a success message. */

t_state	ft_how_are_you(t_philo *philo)
{
	t_state	state;

	pthread_mutex_lock(&philo->mut_state);
	state = philo->state;
	pthread_mutex_unlock(&philo->mut_state);
	return (state);
}

/* The function ft_how_are_you() checks the state of the philosopher. 
   It receives a philosopher as an argument. It locks the mutex of the 
   state of the philosopher, gets the state of the philosopher and unlocks 
   the mutex of the state of the philosopher. Finally, it returns the state 
   of the philosopher. */

void	*ft_are_you_dead(void *data)
{
	int		i;
	int		j;
	t_data	*value;
	t_philo	*philos;

	i = -1;
	value = (t_data *)data;
	philos = value->philos;
	j = ft_num_philos(value);
	while (++i < j && ft_keep_or_not(value))
	{
		if (ft_rip(&philos[i]) && ft_keep_or_not(value))
		{
			ft_writing(value, philos[i].id, DIED);
			ft_keep_flag(value, false);
			ft_game_over(value);
			break ;
		}
		if (i == j - 1)
			i = -1;
		usleep(1000);
	}
	return (NULL);
}

/* The function ft_are_you_dead() checks if the philosopher is dead. It receives
   a data structure as an argument. It checks if the philosopher is dead. If the
   philosopher is dead, it prints the message of the philosopher's death, 
   changes the flag of the data structure to false, and calls the function game 
   over to end the program. Finally, if the philosopher is not dead, it returns 
   NULL. */

//FT_CONTROLLER.C

#include "../includes/philo.h"

bool	ft_keep_or_not(t_data *data)
{
	bool	keep;

	pthread_mutex_lock(&data->mut_keep_iter);
	keep = data->keep_iterating;
	pthread_mutex_unlock(&data->mut_keep_iter);
	return (keep);
}

/* The function ft_keep_or_not() checks if the program should keep iterating. 
   That is, if the program should keep running. It receives a data structure as
   an argument. It locks the mutex of the flag to keep iterating, gets the flag
   to keep iterating, and unlocks the mutex of the flag to keep iterating. 
   Finally, it returns the flag to keep iterating. */

bool	ft_has_eaten(t_data *value, t_philo *philo)
{
	bool	res;

	res = false;
	if (ft_times_eating(philo) >= value->num_meal)
		res = true;
	return (res);
}

/* The function ft_has_eaten() checks if the philosopher has eaten the number 
   of times specified. 
   It receives a data structure and a philosopher as arguments. 
   It checks if the number of times the philosopher has eaten is greater than or
   equal to the number of meals specified. If the number of times the 
   philosopher has eaten is greater than or equal to the number of meals 
   specified, it returns true. Otherwise, it returns false. */

bool	ft_rip(t_philo *philo)
{
	bool		res;
	t_data		*data;

	data = philo->data;
	res = false;
	if (ft_my_watch() - ft_get_last_eat(philo) > ft_get_die(data)
		&& ft_how_are_you(philo) != EATING)
	{
		ft_status(philo, DIE);
		res = true;
	}
	return (res);
}

/* The function ft_rip() checks if the philosopher is dead. It receives a 
   philosopher as an argument. It gets the data structure of the philosopher. 
   It checks if the time since the last meal of the philosopher is greater than
   the time to die and if the philosopher is not eating. If the time since the 
   last meal of the philosopher is greater than the time to die and the 
   philosopher is not eating, it changes the state of the philosopher to dead 
   and returns true. Otherwise, it returns false. */

bool	ft_num_meals(t_data *value)
{
	if (value->num_meal > 0)
		return (true);
	return (false);
}

/* The function ft_num_meals() checks if the number of meals is greater than 0.
   It receives a data structure as an argument. If the number of meals is 
   greater than 0, it returns true. Otherwise, it returns false. */

// FT_EAT_N_THINK.C
#include "../includes/philo.h"

int	ft_times_eating(t_philo *philo)
{
	int	res;

	pthread_mutex_lock(&philo->mut_num_meals);
	res = philo->meals;
	pthread_mutex_unlock(&philo->mut_num_meals);
	return (res);
}

/*	The function ft_times_eating() gets the number of times the philosopher has
	eaten. It receives a philosopher as an argument. It locks the mutex of the 
	number of meals, gets the number of meals, and unlocks the mutex of the 
	number of meals. Finally, it returns the number of meals. */

int	ft_eating(t_philo *philo)
{
	if (get_forks(philo) != 0)
		return (FAILURE);
	ft_status(philo, EATING);
	ft_writing(philo->data, philo->id, EAT);
	ft_get_last_meal(philo);
	ft_sleep_for_eating(philo);
	ft_get_num_meals(philo);
	ft_drop_fork(philo);
	return (SUCCESS);
}

/*	The function ft_eating() is a function that is called when the philosopher 
	is eating. It receives a philosopher as an argument. If the philosopher 
	cannot get the forks, it returns a failure message. Else, it changes the
	state of the philosopher to eating, writes the message that the philosopher
	is eating, gets the last meal time of the philosopher, sleeps for the eating
	time, gets the number of meals of the philosopher, and drops the fork. 
	Finally, it returns a success message. */

int	ft_thinking(t_philo *philo)
{
	ft_status(philo, THINKING);
	if (ft_how_are_you(philo) == DIE)
		return (1);
	ft_writing(philo->data, philo->id, THINK);
	return (SUCCESS);
}

/*	The function ft_thinking() is a function that is called when the philosopher
	is thinking. It receives a philosopher as an argument. It changes the state 
	of the philosopher to thinking. If the philosopher is dead, it returns 1. 
	Else, it writes the message that the philosopher is thinking. Finally, it 
	returns a success message. */

// FTO_FORKS,C
#include "../includes/philo.h"

void	ft_drop_fork(t_philo *philo)
{
	pthread_mutex_unlock(philo->fork_l);
	pthread_mutex_unlock(philo->fork_r);
}

/*	The function ft_drop_fork() drops the forks of the philosopher. It receives
	a philosopher as an argument. It unlocks the mutex of the left fork and the
	mutex of the right fork. */

void	ft_drop_fork_l(t_philo *philo)
{
	pthread_mutex_unlock(philo->fork_l);
}

/*	The function ft_drop_fork_l() drops the left fork of the philosopher. It 
	receives a philosopher as an argument. It unlocks the mutex of the left 
	fork. It used by the function ft_drop_fork(). */

void	ft_drop_fork_r(t_philo *philo)
{
	pthread_mutex_unlock(philo->fork_r);
}

/*	The function ft_drop_fork_r() drops the right fork of the philosopher. It
	receives a philosopher as an argument. It unlocks the mutex of the right 
	fork. It used by the function ft_drop_fork(). */

//FT_FREE_TOOLS.C
#include "../includes/philo.h"

/* void	leaks(void)
{
	system("leaks philo");
}
	Don't use!!!
	The leaks function is used to check for memory leaks. After the program has
	been compiled you can run for example: "./philo 4 800 200 200 5 leaks" or 
	"./philo leaks" and the program will run with the leaks function. If there
	are memory leaks, the program will show you where they are. If there are no
	memory leaks, the program will run without any output. */

void	ft_free_all(t_data *data)
{
	int	i;
	int	j;

	i = -1;
	j = ft_num_philos(data);
	while (++i < j)
	{
		pthread_mutex_destroy(&data->forks[i]);
		pthread_mutex_destroy(&data->philos[i].mut_state);
		pthread_mutex_destroy(&data->philos[i].mut_num_meals);
		pthread_mutex_destroy(&data->philos[i].mut_last_eat);
	}
	pthread_mutex_destroy(&data->mut_die_t);
	pthread_mutex_destroy(&data->mut_eat_t);
	pthread_mutex_destroy(&data->mut_sleep_t);
	pthread_mutex_destroy(&data->mut_nb_philos);
	pthread_mutex_destroy(&data->mut_print);
	pthread_mutex_destroy(&data->mut_keep_iter);
	pthread_mutex_destroy(&data->mut_start_time);
	free(data->philo_ths);
	free(data->philos);
	free(data->forks);
}

/*	The ft_free_all function frees all the memories allocated for the program. 
	It receives a data structure as an argument. It destroys the mutexes of the
	forks, the state, the number of meals, and the last meal of the 
	philosophers.
	It destroys the mutexes of the dying time, the eating time, the sleeping 
	time, the number of philosophers, the print, the flag to keep iterating, 
	and the start time. It frees the threads of the philosophers, the 
	philosophers, and the forks. */

int	ft_malloc(t_data *data)
{
	data->philos = malloc(sizeof(t_philo) * data->nb_philos);
	if (data->philos == NULL)
		return (MALLOC_ERROR);
	data->forks = malloc(sizeof(pthread_mutex_t) * data->nb_philos);
	if (data->forks == NULL)
		return (free(data->philos), MALLOC_ERROR);
	data->philo_ths = malloc(sizeof(pthread_t) * data->nb_philos);
	if (data->philo_ths == NULL)
		return (free(data->philos), free(data->forks), MALLOC_ERROR);
	return (SUCCESS);
}

/*	The ft_malloc function allocates memories for the program. It receives a 
	data structure as an argument. It allocates memories for the philosophers, 
	the forks, and the threads of the philosophers. If the allocation of the 
	memories for the philosophers fails, it returns a malloc error. If the 
	allocation of the memories for the forks fails, it frees the memories 
	allocated for the philosophers and returns a malloc error. If the allocation
	of the memories for the threads of the philosophers fails, it frees the 
	memories allocated for the philosophers and the forks and returns a malloc 
	error. Finally, it returns a success message. */

//FT_GETTERING_A
#include "../includes/philo.h"

void	ft_get_last_meal(t_philo *philo)
{
	pthread_mutex_lock(&philo->mut_last_eat);
	philo->last_eat = ft_my_watch();
	pthread_mutex_unlock(&philo->mut_last_eat);
}

/*	The function ft_get_last_meal() gets the last meal time of the philosopher. 
	It receives a philosopher as an argument. It locks the mutex of the last 
	meal, input the current time as the last meal time, and unlocks the mutex
	of the last meal. */

void	ft_get_num_meals(t_philo *philo)
{
	pthread_mutex_lock(&philo->mut_num_meals);
	philo->meals++;
	pthread_mutex_unlock(&philo->mut_num_meals);
}

/*	The function ft_get_num_meals() gets the number of meals of the philosopher.
	It receives a philosopher as an argument. It locks the mutex of the number 
	of meals, increments the number of meals, and unlocks the mutex of the 
	number of meals. */

uint64_t	ft_get_die(t_data *data)
{
	uint64_t	time;

	pthread_mutex_lock(&data->mut_die_t);
	time = data->die_time;
	pthread_mutex_unlock(&data->mut_die_t);
	return (time);
}

/*	The function ft_get_die() gets the time to die of the philosopher. 
	It receives a data structure as an argument. It locks the mutex of the dying
	time, gets the dying time, and unlocks the mutex of the dying time. Finally,
	it returns the dying time. */

uint64_t	ft_get_eat(t_data *data)
{
	uint64_t	time;

	pthread_mutex_lock(&data->mut_eat_t);
	time = data->eat_time;
	pthread_mutex_unlock(&data->mut_eat_t);
	return (time);
}

/*	The function ft_get_eat() gets the time to eat of the philosopher. 
	It receives a data structure as an argument. It locks the mutex of the 
	eating time, gets the eating time, and unlocks the mutex of the eating 
	time. Finally, it returns the eating time. */

uint64_t	ft_get_last_eat(t_philo *philo)
{
	uint64_t	time;

	pthread_mutex_lock(&philo->mut_last_eat);
	time = philo->last_eat;
	pthread_mutex_unlock(&philo->mut_last_eat);
	return (time);
}

/*	The function ft_get_last_eat() gets the last meal time of the philosopher.
	It receives a philosopher as an argument. It locks the mutex of the last 
	meal, gets the last meal time, and unlocks the mutex of the last meal. 
	Finally, it returns the last meal time. */

//FT_GETTERING_b
#include "../includes/philo.h"

int	ft_get_fork_l(t_philo *philo)
{
	if (ft_rip(philo) || ft_how_are_you(philo) == DIE)
		return (FAILURE);
	pthread_mutex_lock(philo->fork_l);
	ft_writing(philo->data, philo->id, TAKE_FORKS);
	return (SUCCESS);
}

/*	The function ft_get_fork_l() gets the left fork of the philosopher. It 
	receives a philosopher as an argument. If the philosopher is dead or 
	the philosopher is dying, it returns a failure message. Else, it locks 
	the mutex of the left fork, writes the message that the philosopher has 
	taken the forks, and returns a success message. */

int	ft_get_fork_r(t_philo *philo)
{
	if (ft_rip(philo) || ft_how_are_you(philo) == DIE)
		return (FAILURE);
	pthread_mutex_lock(philo->fork_r);
	ft_writing(philo->data, philo->id, TAKE_FORKS);
	return (SUCCESS);
}

/*	The function ft_get_fork_r() gets the right fork of the philosopher. It 
	receives a philosopher as an argument. If the philosopher is dead or the 
	philosopher is dying, it returns a failure message. Else, it locks the 
	mutex of the right fork, writes the message that the philosopher has taken 
	the forks, and returns a success message. */

int	get_forks(t_philo *philo)
{
	if (ft_num_philos(philo->data) == 1)
		return (ft_only_one(philo));
	if (ft_get_fork_r(philo) != 0)
		return (FAILURE);
	if (ft_get_fork_l(philo) != 0)
	{
		ft_drop_fork_r(philo);
		return (FAILURE);
	}
	return (SUCCESS);
}

/*	The function get_forks() gets the forks of the philosopher. It receives a 
	philosopher as an argument. If there is only one philosopher, it calls the 
	function ft_only_one(). Else, it gets the right fork of the philosopher. 
	If the philosopher cannot get the right fork, it returns a failure message. 
	Else, it gets the left fork of the philosopher. If the philosopher cannot 
	get the left fork, it drops the right fork and returns a failure message. 
	Finally, it returns a success message. */

//FT_GETTERING_c
#include "../includes/philo.h"

uint64_t	ft_get_start(t_data *data)
{
	uint64_t	time;

	pthread_mutex_lock(&data->mut_start_time);
	time = data->start_time;
	pthread_mutex_unlock(&data->mut_start_time);
	return (time);
}

/*	The function ft_get_start() gets the start time of the program. It receives 
	a data structure as an argument. It locks the mutex of the start time, gets 
	the start time, and unlocks the mutex of the start time. Finally, it returns 
	the start time. */

uint64_t	ft_get_sleep(t_data *data)
{
	uint64_t	time;

	pthread_mutex_lock(&data->mut_sleep_t);
	time = data->sleep_time;
	pthread_mutex_unlock(&data->mut_sleep_t);
	return (time);
}

/*	The function ft_get_sleep() gets the time to sleep of the philosopher. 
	It receives a data structure as an argument. It locks the mutex of the 
	sleeping time, gets the sleeping time, and unlocks the mutex of the sleeping 
	time. Finally, it returns the sleeping time. */

//FT_INIT
#include "../includes/philo.h"

int	ft_init_values(t_data *data, int argc, char **argv)
{
	if (argc == 6)
		data->num_meal = ft_atoi(argv[5]);
	else
		data->num_meal = -1;
	data->eat_time = (uint64_t) ft_atoi(argv[3]);
	data->die_time = (uint64_t) ft_atoi(argv[2]);
	data->sleep_time = (uint64_t) ft_atoi(argv[4]);
	data->finished = 0;
	data->nb_philos = ft_atoi(argv[1]);
	data->keep_iterating = true;
	pthread_mutex_init(&data->mut_eat_t, NULL);
	pthread_mutex_init(&data->mut_die_t, NULL);
	pthread_mutex_init(&data->mut_sleep_t, NULL);
	pthread_mutex_init(&data->mut_keep_iter, NULL);
	pthread_mutex_init(&data->mut_nb_philos, NULL);
	pthread_mutex_init(&data->mut_print, NULL);
	pthread_mutex_init(&data->mut_start_time, NULL);
	return (ft_malloc(data));
}

/*	The function ft_init_values() initializes the values of the data structure. 
	It receives a data structure, the number of arguments, and the arguments. 
	If the number of arguments is 6, it assigns the number of meals to the data 
	structure. Otherwise, it assigns -1 if the number of meals is not specified.
	-1 means that the number of meals is not specified. It assigns the eating
	time, the dying time, the sleeping time, the number of full philosophers,
	the number of philosophers, and the flag to keep iterating. It initializes
	the mutexes of the eating time, the dying time, the sleeping time, the flag
	to keep iterating, the number of philosophers, the print, and the start 
	time.
	Finally, it returns the result of the function ft_malloc() that allocates
	memories for the program. */

int	ft_init_threads(t_data *data)
{
	int	i;
	int	j;

	i = -1;
	j = ft_num_philos(data);
	data->start_time = ft_my_watch();
	while (++i < j)
	{
		if (pthread_create(&data->philo_ths[i], NULL,
				&ft_the_core, &data->philos[i]))
			return (FAILURE);
	}
	if (pthread_create(&data->monit_all_alive, NULL,
			&ft_are_you_dead, data))
		return (FAILURE);
	if (ft_num_meals(data) == true
		&& pthread_create(&data->monit_all_full, NULL,
			&ft_the_watchdog, data))
		return (FAILURE);
	return (SUCCESS);
}

/*	The function ft_init_threads() initializes the threads of the philosophers.
	It receives a data structure as an argument. It initializes the start time 
	of the data structure. It creates the threads of the philosophers. If the 
	creation of the thread fails, it returns a failure message. It creates the 
	thread that monitors if all the philosophers are alive. If the creation of 
	the thread fails, it returns a failure message. If the number of meals is 
	true, it creates the thread that monitors if all the philosophers have eaten
	If the creation of the thread fails, it returns a failure message. Finally, 
	it returns a success message if everything is correct. */

int	ft_init_philos(int argc, char **argv)
{
	t_data	values;

	if (ft_init_values(&values, argc, argv) != 0)
		return (MALLOC_ERROR);
	ft_init_philos_data(&values);
	ft_init_forks(&values);
	ft_init_threads(&values);
	ft_sincro(&values);
	ft_free_all(&values);
	return (SUCCESS);
}

/*	The function ft_init_philos() initializes the philosophers. It receives the 
	number of arguments and the arguments. It creates a data structure. If the 
	initialization of the values of the data structure fails, it returns a malloc
	error. It initializes the data of the philosophers. It initializes the forks.
	It initializes the threads of the philosophers. It waits for the threads to 
	finish. Finally, it frees all the memories allocated for the program. */

int	ft_init_philos_data(t_data *data)
{
	t_philo	*philos;
	int		i;

	i = -1;
	philos = data->philos;
	while (++i < data->nb_philos)
	{
		philos[i].data = data;
		philos[i].id = i + 1;
		philos[i].meals = 0;
		philos[i].state = OFF;
		pthread_mutex_init(&philos[i].mut_state, NULL);
		pthread_mutex_init(&philos[i].mut_num_meals, NULL);
		pthread_mutex_init(&philos[i].mut_last_eat, NULL);
		ft_get_last_meal(&philos[i]);
	}
	return (SUCCESS);
}

/*	The function ft_init_philos_data() initializes the data of the philosophers.
	It receives a data structure as an argument. 
	It initializes the philosophers, the id, the number of meals, the state, 
	and the mutexes of the state, the number of meals, and the last meal. 
	ft_get_last_meal() initializes the last meal of the philosopher. 
	Finally, it returns a success message. */

int	ft_init_forks(t_data *data)
{
	int		i;
	t_philo	*philos;

	i = -1;
	philos = data->philos;
	while (++i < data->nb_philos)
		pthread_mutex_init(&data->forks[i], NULL);
	i = 0;
	philos[0].fork_l = &data->forks[0];
	philos[0].fork_r = &data->forks[data->nb_philos - 1];
	while (++i < data->nb_philos)
	{
		philos[i].fork_l = &data->forks[i];
		philos[i].fork_r = &data->forks[i - 1];
	}
	return (SUCCESS);
}

/*	The function ft_init_forks() initializes the forks of the philosophers. It 
	receives a data structure as an argument. It initializes the forks of the 
	philosophers. It initializes the left fork of the philosopher and the 
	right fork of the first philosopher, the right fork of the philosopher is 
	the left fork of the previous philosopher. Finally, it returns a success if
	everything is correct. */

//FT_PHILO 
#include "../includes/philo.h"

int	main(int argc, char **argv)
{
	if (ft_check_args(argc, argv) != 0)
	{
		ft_instruction();
		return (INPUT_ERROR);
	}
	if (ft_init_philos(argc, argv) != 0)
		return (MALLOC_ERROR);
	return (SUCCESS);
}

/* The main function is the entry point of the program. It checks the arguments:
   if the number of arguments is less than 5 or more than 6, or if the arguments
   are not numbers, or if the arguments are less than 60, it calls the function
   to print the instructions and returns an error. Afer, it calls the function
   to initialize the philosophers; if the initialization fails, it returns an
   error. Finally, it returns a success message if everything is correct. */

void	*ft_the_core(void *philo)
{
	t_philo	*value;

	value = (t_philo *) philo;
	ft_get_last_meal(value);
	if (value->id % 2 == 0)
		ft_delay(value->data->eat_time - 10);
	while (ft_how_are_you(value) != DIE)
	{
		if (ft_eating(value) != 0)
			break ;
		if (ft_thinking(value) != 0)
			break ;
		if (ft_sleeping(value) != 0)
			break ;
		if (ft_how_are_you(value) == DIE)
			break ;
	}
	return (NULL);
}

/* The function ft_the_core() is very important function of the philosopher. 
   It receives a philosopher as an argument. It gets the last meal time of the 
   philosopher. If the number of the philosopher is even, it delays the eating
   time by 10 ms. While the philosopher is alive, it checks if the philosopher
   is eating, thinking, or sleeping and if the philosopher is dead. If eating,
   thinking, or sleeping fails, or the philosopher is dead, it breaks the loop.
   Finally, it returns NULL. */	

int	ft_only_one(t_philo *philo)
{
	ft_get_fork_l(philo);
	ft_delay(ft_get_die(philo->data));
	ft_status(philo, DIE);
	return (FAILURE);
}

/* The function ft_only_one() is a function that is called when there is only 
   one philosopher. It receives a philosopher as an argument. It gets the left
   fork of the philosopher but does not get the right fork, because there is no
   right fork. It delays the time to die of the philosopher and changes the
   state of the philosopher to dead. Finally, it returns a failure message. */

void	*ft_the_watchdog(void *phi_value)
{
	int		i;
	int		j;
	t_data	*value;

	i = -1;
	value = (t_data *)phi_value;
	j = ft_num_philos(value);
	while (++i < j && ft_keep_or_not(value))
	{
		usleep(1000);
		if (ft_has_eaten(value, &value->philos[i]) == false)
			i = -1;
	}
	if (ft_keep_or_not(value) == true)
	{
		ft_keep_flag(value, false);
		ft_game_over(value);
	}
	return (NULL);
}

/* The function ft_the_watchdog() is a function that is called when there is 
   more than one philosopher. It receives a data structure as an argument. 
   While the philosophers are alive, it checks if the philosophers have eaten. 
   If a philosopher has not eaten, it resets the counter of the philosopher. 
   If all the philosophers have eaten, it changes the flag of the data structure 
   to false and calls the function game over to print the message. Finally, it
   returns NULL. */

int	ft_sincro(t_data *data)
{
	int	i;
	int	j;

	i = -1;
	j = ft_num_philos(data);
	if (pthread_join(data->monit_all_alive, NULL))
		return (FAILURE);
	if (ft_num_meals(data) == true
		&& pthread_join(data->monit_all_full, NULL))
		return (FAILURE);
	while (++i < j)
	{
		if (pthread_join(data->philo_ths[i], NULL))
			return (FAILURE);
	}
	return (SUCCESS);
}

/* The function ft_sincro() is a function that is called when the philosophers
   have finished eating. It receives a data structure as an argument. It waits 
   for the thread that monitors if all the philosophers are alive. 
   If the number of meals is true, it waits for the thread that monitors if 
   all the philosophers have eaten. 
   Finally, it waits for all the threads of the philosophers and returns a 
   success message if everything is correct. */

//FT_PRINTING
#include "../includes/philo.h"

void	ft_writing(t_data *data, int id, char *src)
{
	uint64_t	i;

	i = ft_my_watch() - ft_get_start(data);
	pthread_mutex_lock(&data->mut_print);
	if (ft_keep_or_not(data))
		printf("%lu %d %s\n", i, id, src);
	pthread_mutex_unlock(&data->mut_print);
}

/*	The function ft_writing() writes the message of the philosopher. It receives
	a data structure, the id of the philosopher, and the message. It gets the 
	current time, locks the mutex of the print, writes the message of the 
	philosopher, and unlocks the mutex of the print. */

void	ft_instruction(void)
{
	printf(BDBLUE"\n\n");
	printf("‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà  ‚ñà ‚ñà ‚ñà    ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà  ‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà\n");
	printf("‚ñà   ‚ñà ‚ñà  ‚ñà ‚ñà ‚ñà    ‚ñà  ‚ñà ‚ñà    ‚ñà  ‚ñà ‚ñà  ‚ñà ‚ñà  ‚ñà ‚ñà    ‚ñà  ‚ñà ‚ñà   \n");
	printf("‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà ‚ñà    ‚ñà  ‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà  ‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà\n");
	printf("‚ñà     ‚ñà  ‚ñà ‚ñà ‚ñà    ‚ñà  ‚ñà    ‚ñà ‚ñà  ‚ñà ‚ñà    ‚ñà  ‚ñà ‚ñà    ‚ñà  ‚ñà    ‚ñà\n");
	printf("‚ñà     ‚ñà  ‚ñà ‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà    ‚ñà  ‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà  ‚ñà ‚ñà‚ñà‚ñà‚ñà\n\n");
	printf(RESET"                   by sternero(nov.2024)\n\n");
	printf(BDYELLOW "\tRemember, üò° you must enter...\n\n" RESET);
	printf("./philo +\n");
	printf("number of philosophers (must be a number between 1 and 200) +\n");
	printf("time to die (must be a number greater than 60 ms.) +\n");
	printf("time to eat (must be a number greater than 60 ms.) +\n");
	printf("time to sleep (must be a number greater than 60 ms.) +\n\n");
	printf(BDGREEN"üò≥ Optionally "RESET);
	printf(": the number of times each phyllo must eat.\n\n");
	printf(BDBLUE"\tNow let's see an example:\t"RESET);
	printf("./philo 4 800 200 200 5\n\n");
	printf("This will create 4 philosophers, ");
	printf("each with a time to die üò≠ of 800 ms,\n");
	printf("a time to eat ü§§ of 200 ms, a time to sleep ü•± of 200 ms,\n");
	printf("and each philosopher must eat 5 times.\n\n");
	printf(BDRED"üòµ‚Äçüí´ Don't be confused"RESET"... and ");
	printf("enjoy the experience. ü§™\n\n");
}

/*	The function ft_instruction() prints the instructions of the program when 
	the arguments are incorrect or without arguments. */

//FT_SLEEP
#include "../includes/philo.h"

int	ft_sleeping(t_philo *philo)
{
	ft_status(philo, SLEEPING);
	if (ft_how_are_you(philo) == DIE)
		return (FAILURE);
	ft_writing(philo->data, philo->id, SLEEP);
	ft_delay(ft_get_sleep(philo->data));
	return (SUCCESS);
}

/*	The function ft_sleeping() is a function that is called when the philosopher
	is sleeping. It receives a philosopher as an argument. It changes the state 
	of the philosopher to sleeping. If the philosopher is dead, it returns a 
	failure message. Else, it writes the message that the philosopher is 
	sleeping, sleeps for the sleeping time, and returns a success message. */

void	ft_sleep_for_eating(t_philo *philo)
{
	ft_delay(ft_get_eat(philo->data));
}

/*	The function ft_sleep_for_eating() sleeps for the eating time of the 
	philosopher. It receives a philosopher as an argument. It delays the eating 
	time of the philosopher. */

//FT_TOOLS_1
#include "../includes/philo.h"

void	ft_delay(uint64_t pause)
{
	uint64_t	ini;

	ini = ft_my_watch();
	while ((ft_my_watch() - ini) < pause)
		usleep(500);
}

/*	The function ft_delay() delays the program for the time specified. 
	It receives a time as an argument. It gets the current time, and while the 
	difference between the current time and the initial time is less than the 
	time specified, it sleeps for 500 ms. */

uint64_t	ft_my_watch(void)
{
	struct timeval	ms;

	if (gettimeofday(&ms, NULL))
		return (SUCCESS);
	return ((ms.tv_sec * (uint64_t)1000) + (ms.tv_usec / 1000));
}

/*	The function ft_my_watch() gets the current time. It creates a timeval 
	structure. The gettimeofday() function is the time of day. It gets the
	time of day and returns the current time. tv_sec is the number of seconds
	since the Epoch (00:00:00 UTC, January 1, 1970). tv_usec is the number of
	microseconds. */

int	ft_atoi(char *str)
{
	int		i;
	long	res;
	int		sign;

	i = 0;
	res = 0;
	sign = 1;
	while (str[i] == '\r' || str[i] == '\t' || str[i] == ' '
		|| str[i] == '\f' || str[i] == '\v' || str[i] == '\n')
		i++;
	if (str[i] == '-')
	{
		sign = -1;
		i++;
	}
	else if (str[i] == '+')
		i++;
	if (!(str[i] >= '0' && str[i] <= '9'))
		return (0);
	while (str[i] >= '0' && str[i] <= '9')
		res = res * 10 + (str[i++] - '0');
	return (res * sign);
}

/*	The function ft_atoi() converts a string to an integer. It receives a string
	as an argument. It initializes the index, the result, and the sign. It skips 
	whitespace characters. If the character is a minus sign, it assigns the sign 
	to -1 and increments the index. If the character is a plus sign, 
	it increments the index. If the character is not a digit, it returns 0. 
	While the character is a digit, it multiplies the result by 10 and adds the 
	character minus '0'. Finally, it returns the result multiplied by the sign. 
*/

//FT_TOOLS_2
#include "../includes/philo.h"

int	ft_num_philos(t_data *data)
{
	int	i;

	pthread_mutex_lock(&data->mut_nb_philos);
	i = data->nb_philos;
	pthread_mutex_unlock(&data->mut_nb_philos);
	return (i);
}

/*	The function ft_num_philos() gets the number of philosophers. It receives a 
	data structure as an argument. It locks the mutex of the number of 
	philosophers, gets the number of philosophers, and unlocks the mutex of the 
	number of philosophers. Finally, it returns the number of philosophers. */

void	ft_game_over(t_data *value)
{
	int		i;
	int		j;
	t_philo	*philos;

	i = -1;
	j = ft_num_philos(value);
	philos = value->philos;
	while (++i < j)
		ft_status(&philos[i], DIE);
}

/*	The function ft_game_over() changes the state of the philosophers to die. 
	It receives a data structure as an argument. It gets the number of 
	philosophers, the philosophers, and changes the state of the philosophers 
	to die. */

void	ft_keep_flag(t_data *value, bool now)
{
	pthread_mutex_lock(&value->mut_keep_iter);
	value->keep_iterating = now;
	pthread_mutex_unlock(&value->mut_keep_iter);
}

/*	The function ft_keep_flag() changes the flag of the data structure to keep 
	running. It receives a data structure and a boolean as arguments. It locks 
	the mutex of the flag to keep iterating, changes the flag to keep iterating, 
	and unlocks the mutex of the flag to keep iterating. It is used to stop the
	program when a philosopher dies. */

void	ft_status(t_philo *philo, t_state status)
{
	pthread_mutex_lock(&philo->mut_state);
	if (philo->state != DIE)
		philo->state = status;
	pthread_mutex_unlock(&philo->mut_state);
}

/*	The function ft_status() changes the state of the philosopher. It receives a
	philosopher and a state as arguments. It locks the mutex of the state of the
	philosopher, changes the state of the philosopher, and unlocks the mutex of
	the state of the philosopher. It is used when the philosopher is eating,
	thinking, or sleeping. */

/*

void	print_num_meal_had(t_philo *philo)
{
	t_data	*data;

	data = philo->data;
	pthread_mutex_lock(&data->mut_print);
	printf("Philo %d ate %d times\n", philo->id, philo->meals);
	pthread_mutex_unlock(&data->mut_print);
}
*/


/*
void	wait_until(uint64_t wakeup_time)
{
	int			margin;
	uint64_t	time;

	margin = 5;
	while (1)
	{
		time = ft_my_watch();
		if (wakeup_time <= time + margin)
		{
			while (wakeup_time > time)
				time = ft_my_watch();
			break ;
		}
		else
		{
			usleep(1000 * (wakeup_time - time - margin));
		}
	}
}
*/

/*
void	print_mut(t_data *data, char *msg)
{
	pthread_mutex_lock(&data->mut_print);
	printf("%s\n", msg);
	pthread_mutex_unlock(&data->mut_print);
}
*/
